<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualisation de Graphe avec Sigma.js</title>

 <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
	
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/sigma.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.2.1/plugins/sigma.layout.forceAtlas2.min.js"></script>

 <script src="./bundle.js"></script>
 
 <script>
window.addEventListener("load", function () {
    console.log("üìå V√©rification apr√®s chargement complet des scripts...");

    console.log("üìå V√©rification de sigma :", window.sigma);
    console.log("üìå V√©rification de forceatlas2 :", window.forceAtlas2);
    console.log("üìå V√©rification de graphology :", window.graphology);
    console.log("üìå V√©rification de pandemonium :", window.pandemonium);
    console.log("üìå V√©rification de graphology-indices :", window.graphologyIndices);
    console.log("üìå V√©rification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
});
</script>
 
  <link rel="icon" href="data:,">
 
<!-- STYLE----------------------------------------------------------------------------------------------------- -->
 <style>
 
.container {
    display: flex;
    justify-content: space-between;
    align-items: stretch;  /* ‚úÖ Toutes les colonnes prennent la m√™me hauteur */
    height:83vh;  /* ‚úÖ Utilise toute la hauteur de l'√©cran */
}

/* ‚úÖ Colonne de gauche */
#left-panel {
    width: 250px;
    padding: 1px;
    border-right: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

/* ‚úÖ Colonne de droite */
#right-panel {
    width: 250px;
    padding: 1px;
    border-left: 1px solid #ccc;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

/* ‚úÖ Zone du graphe - Ajuste la hauteur automatiquement */
#graph-container {
    flex-grow: 1;
	  max-height:100%;  /*‚úÖ Permet au graphe de prendre la m√™me hauteur que les colonnes */
    border: 1px solid #ccc;
    background: #f9f9f9;
    display: flex;
    align-items: stretch;  /* ‚úÖ Ajuste le graphe √† la hauteur de son parent */
	position: relative; /* ‚úÖ Cette ligne est essentielle pour que les enfants absolus s‚Äôalignent par rapport √† lui */
    overflow: hidden;    /* ‚úÖ Pour √©viter les d√©bordements */
	width: 100%;
	height: 100%;
}

/* ‚úÖ Style du conteneur de recherche */
#search-container {
    padding: 5px;
    border: 2px solid #ddd;
    background: #f9f9f9;
    margin-bottom: 4px;
    border-radius: 2px;
	position: relative
}

/* ‚úÖ Style de la zone de saisie et du bouton */
#node-search {
    width: 90%;
	font-size: 12px;
    padding: 6px;
    margin-bottom: 5px;
    border: 2px solid #ccc;
    border-radius: 4px;
}

#search-node-btn {
    width: 80%;
    padding: 6px;
    font-size: 14px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-node-btn:hover {
    background-color: #2980b9;
}

#search-initial-btn  {
    width: 90%;
    padding: 6px;
    font-size: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#search-initial-btn:hover {
    background-color: #2980b9;
}

/* ‚úÖ Liste des r√©sultats de recherche */
#search-results {
    list-style-type: none;
    padding: 0;
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    border: 1px solid #ccc;
    background: white;
    border-radius: 4px;
}

#search-results li {
    padding: 8px;
    cursor: pointer;
    transition: background 0.3s;
    border-bottom: 1px solid #ddd;
}

#search-results li:hover {
    background: #f1f1f1;
}

#info-text {
    flex-grow: 1;
    overflow-y: auto;
    max-height: 110px;
    max-width: 230px;
    word-wrap: break-word;
    padding: 10px;
    border: 1px solid #ccc; /* ‚úÖ Bordure pour d√©marquer */
    background: #f9f9f9; /* ‚úÖ Fond clair */
    border-radius: 4px; /* ‚úÖ Arrondi des coins */
	margin-bottom: 5px;  /* ‚úÖ Ajoute de l'espace sous cette zone */
}

#info-buttons {
    display: flex;
    flex-direction: column;
    gap: 5px;  /* ‚úÖ Espacement entre les boutons */
	margin-bottom: 6px; 
    padding-top: 10px; /* ‚úÖ Ajoute de l‚Äôespace au-dessus des boutons */
}

button {
    width: 90%;  
    padding: 10px;
    font-size: 12px;
    background-color: #3498db; 
    color: white;
    border: none;
    border-radius: 4px; 
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 10px;  /* Augmente l'espacement sous chaque bouton */
}

/* Effet au survol */
button:hover {
    background-color: #2980b9;
}

#show-neighbors-btn {
    width: 80%;
    padding: 5px;
    font-size: 12px;
    background-color:  #ff9933  ; /* ‚úÖ synonymes brun clair */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-neighbors-btn:hover {
    background-color: #d35400;
}

#show-neighbors-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#show-cliques-btn {
    width: 80%;
    padding: 5px;
    font-size: 12px;
    background-color:  #ff9933  ;  
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-cliques-btn:hover {
    background-color: #d35400;
}

#show-cliques-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#show-syno2-btn {
    width: 80%;
    padding: 8px;
    font-size: 12px;
    background-color: #ff9933 ; /* ‚úÖ syno2*/
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#show-syno2-btn:hover {
    background-color:  #d35400;
}

#show-syno2-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#show-adjacency-btn {
    width: 80%;
    padding: 8px;
    font-size: 12px;
    background-color: #ff9933; /* ‚úÖ  bouton adjacence */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
	margin-bottom: 1px;
}

#show-adjacency-btn:hover {
    background-color: #d35400;
}

#show-adjacency-btn:disabled {
    background-color: #bdc3c7; /* ‚úÖ Gris quand d√©sactiv√© */
    cursor: not-allowed;
}

#graph-management {
    padding: 10px;
    border: 4px solid #2980b9;  /* ‚úÖ Bordure √©paisse bleue */
    border-radius: 8px;  /* ‚úÖ Coins arrondis */
    background: #f9f9f9;  /* ‚úÖ Fond clair */
    text-align: center;
    margin-top: 1px;
}

#graph-management h3 {
    margin-top: 0;
    font-size: 12px;
    color: #2980b9;
}
#community-legend {    /* COMMUNAUTES */
    width: auto;
    max-width: 115px; /* ‚úÖ R√©duit la largeur du cadre pour 1 colonne */
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* ‚úÖ Meilleur alignement √† gauche */
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position:  relative;
    top: 1px;
	left : 1px ;
    z-index: 10;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
}

/* ‚úÖ Conteneur des pastilles avec 2 colonnes */
#community-items {  
	display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
   justify-content: space-between;
}

/* ‚úÖ √âl√©ments de la l√©gende (adapt√©s pour 2 colonnes) */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); /* ‚úÖ Deux colonnes maximum */
    min-width: 90px;
}

/* ‚úÖ Pastille de couleur */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s ease-in-out;
}

/* ‚úÖ Effet zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

/* ‚úÖ Labels des communaut√©s */
.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ‚úÖ Style du bouton "Toutes Communaut√©s" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9;
}

#hide-legend-zone {
    width: 80%;
    text-align: center;
    padding: 5px;
    background: #a3a3c2;
    color: white;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
}

#hide-legend-zone:hover {
    background: #c0392b;
}

#show-legend-btn {
    padding: 5px;
    background: #2ecc71;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    display: none;
}

#hide-legend-btn {
    width: 100%;
    margin-top: 10px;
    padding: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s ease;
}

#hide-legend-btn:hover {
    background-color:  #a3a3c2;
}

#connected-components-legend {  /* CONNEXES */
    width: auto;
    max-width:180px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding: 5px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    position: relative;        
    top: 1px;              /* ‚úÖ d√©calage depuis le haut de la page */
    left: 1px;
    z-index: 10 ;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
	/*  hauteur fixe + scroll */
    max-height: 500px;
    overflow-y: auto;
	 overflow-x: hidden;
	
}

#connected-components-legend .legend-item {
    width: 100% !important;
    min-width: 100px !important;
    box-sizing: border-box;
}

/* ‚úÖ Conteneur   */
#legend-items {
	display: flex;
    flex-wrap: wrap;
    max-height: 500px;
    overflow-y: auto;
    gap: 5px;
    justify-content: space-between;
}

/* ‚úÖ Chaque pastille prend la moiti√© de la ligne = 2 colonnes */
.legend-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    transition: all 0.3s ease-in-out;
    width: calc(50% - 10px); 
    min-width: 90px;
    box-sizing: border-box; /* ‚úÖ Pour une meilleure coh√©rence d‚Äôaffichage */
}

/* ‚úÖ Pastilles */
.color-dot {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    border: 1px solid #000;
    transition: transform 0.2s ease-in-out;
}

/* ‚úÖ Zoom au survol */
.legend-item:hover .color-dot {
    transform: scale(1.2);
}

.legend-label {
    font-size: 14px;
    font-weight: bold;
}

/* ‚úÖ Style du bouton "Toutes Composantes" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db; /* ‚úÖ Bleu Sigma.js */
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
}

.show-all-button:hover {
    background-color: #2980b9; /* ‚úÖ Bleu fonc√© au survol */
}

/* ‚úÖ Bouton "TOUTES Communaut√©s" */
.show-all-button {
    margin-top: 10px;
    background-color: #3498db;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
}

.show-all-button:hover {
    background-color: #2980b9;
}

/* ‚úÖ Bouton "Masquer" */
.hide-legend-button {
    margin-top: 5px;
    background-color: #bdc3c7;
    color: white;
    border: none;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.3s ease-in-out;
    width: 100%;
	 display: block; /* ‚úÖ Assurer qu'il est bien affich√© */
}

.hide-legend-button:hover {
    background-color: #e74c3c; /* ‚úÖ Rouge au survol */
}

#graph-stats-display {
    position: absolute;
    top: 1px;
    left: 1px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 4px;
    font-weight: bold;
    z-index: 10;
    border: 1px solid #ccc;
}

#graph-titre-display {
    position: absolute;
    top: 1px;
    left: 200px;
    background-color: rgba(255, 255, 255, 0.85);
    padding: 4px 8px;
    font-size: 12px;
    border-radius: 4px;
    font-weight: bold;
    z-index: 10;
    border: 1px solid #ccc;
}

 /* ‚úÖ Style pour la notification */
.graph-notification {
    position: absolute;
    top: 25px;
    left: 400px;
    background-color: #33cc33;
    color: #336600;
    border: 2px solid #ccc;
    padding: 8px 12px;
    border-radius: 5px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    font-size: 14px;
    z-index: 9999;
    display: none;
    max-width: 500px;
}

#btn-mode-chemin {
  background-color: #ce7e00;
  color: white;
  border: none;
  padding: 6px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 12px;
  transition: background 0.3s ease-in-out;
  margin-top: 10px;
}

#btn-mode-chemin.active {
  background-color: #1bcc53;
  font-size: 12px;
}

.clique-symbol {
    display: inline-block;
    width: 15px;
    height: 15px;
    line-height: 15px;
    text-align: center;
    background-color: green;
    color: white;
    border-radius: 50%;
    cursor: pointer;
    margin-right: 5px;
    font-size: 12px;
}

#clique-popup {
    position: fixed;
    top: 20px;      /* ‚úÖ marge par rapport au haut de la page */
    left: 20px;     /* ‚úÖ marge par rapport au bord gauche */
    width: 300px;   /* ‚úÖ largeur fixe */
    max-height: 400px;  /* ‚úÖ hauteur max avec scroll si d√©passe */
    overflow-y: auto;
    background: white;
    border: 1px solid black;
    padding: 10px;
    z-index: 9999;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    border-radius: 5px;
}

  </style>
  <!-- FIN STYLE----------------------------------------------------------------------------------------------------- -->


</head>
<body>

 <h1>Graphes de synonymes</h1>

<!-- DIV----------------------------------------------------------------------------------------------------- -->

  <div class="container">
  
  <!-- ‚úÖ COLONNE DE GAUCHE (INFOS & RECHERCHE PAR MOT) -->
	<div id="left-panel"> 
		
		<div id="graph-management">
				
			<div id="info-text"></div>			
			<div id="search-container">
			<input type="text" id="node-search" placeholder="Rechercher un mot..." />
			<button id="search-node-btn" title="Taper au clavier, dans la zone de saisie ci-dessus, des caract√®res contenus dans le mot recherch√©, cliquer sur le bouton et s√©lectionner dans la liste d√©roulante ci-dessous le mot recherch√©.">Rechercher dans le graphe en cours</button>
			<ul id="search-results"></ul>
			</div>	
			
		<h3>Approche individuelle</h3>	
			<!-- ‚úÖ boutons pour afficher les graphes de la vedette -->
			<button id="show-neighbors-btn" title="Synonymes du mot s√©lectionn√©, dans le graphe en cours (complet ou filtr√©)." disabled>Synonymes 1</button>
			<button id="show-adjacency-btn" title="Relations de synonymie entre les synonymes du mot s√©lectionn√©, dans le graphe en cours (complet ou filtr√©)." disabled>Adjacence</button>	
			<div id="info-buttons"></div>
			<button id="show-syno2-btn" title="Synonymes de rang 1 (bleus) et 2 (oranges) du mot s√©lectionn√©, dans le graphe en cours (complet ou filtr√©)." disabled>Synonymes 1 et 2</button>
			<button id="show-cliques-btn" title="Cliques du mot s√©lectionn√© (sous-ensembles maximums de synonymes tous synonymes les uns des autres), dans le graphe complet. " disabled>Cliques</button>
			
			<button id="btn-mode-chemin"title="Indique le chemin de synonymie le plus court, dans le graphe complet, entre 2 mots s√©lectionn√©s." >Chemin entre deux mots</button>			 

		<h3>Approche par graphe</h3>
		<!-- ‚úÖ bouton Histogramme, compl√©tude, extension, export des 2 matrices -->	
			<button id="show-histo-btn"title="Histogramme du graphe affich√© : nombre de liens/nombre de mots."style=" background-color: #b35900;">Histogramme</button>
			<button id="extension-btn" title="Ajout, aux mot affich√©s, des synonymes existants dans le graphe en cours. Affichage sans les liens de synonymie qui peuvent √™tre trac√©s en cliquant ensuite sur le bouton Compl√©tude." style=" background-color: #b35900;" >Extension</button>
			<button id="completude-btn" title="Ajout, aux mots affich√©s, de toutes les relations de synonymie existantes dans le graphe en cours." style=" background-color: #b35900;" >Compl√©tude</button>
			
			<button id="show-connected-components-btn" title="Affiche les composantes connexes du graphe affich√© (sous ensembles disjoints de mots).">Connexes</button>
			<button id="detect-communities" title="Affiche les sous groupes de mots fortement interconnect√©s (algorithme de Louvain) du graphe affich√©.">Communaut√©s</button>
			<button id="show-legend-btn" style="display:none;">Afficher la l√©gende</button>
		
		</div>
		
	</div>
	
<!-- ‚úÖ ZONE D'AFFICHAGE DU GRAPHE -->	
	
	<div id="graph-container">
			
		<div id="graph-title-banner" style="
		position: absolute;
		text-align: left;
		font-weight: bold;
		font-size: 12px;
		margin-bottom: 10px;
		margin-left: 500px;     /* ‚úÖ marge par rapport au bord gauche */
		margin-width:200px;   /* ‚úÖ largeur fixe */
		height: 10px; 
		width: 320px; 	
		padding: 6px;
		background-color: #f0f0f0;
		border-bottom: 2px solid #ccc; 
		z-index: 100;">
		...
		</div>
	
	<!-- ‚úÖ stat points, liens plac√©e en haut √† gauche du conteneur -->
		<div id="graph-stats-display">0 mot, 0 lien</div>
		
	<!-- ‚úÖ titre du graphe, √† droite des stat -->
		<div id="graph-titre-display">...</div>			
		<!-- ‚úÖ Notification plac√©e en haut √† droite du conteneur -->
		<div id="notification" class="graph-notification">Notification...</div>
	 
	</div>
		<!-- L√©gende des communaut√©s  -->
		<div id="community-legend"style="display: none;" >
		<h3>Communaut√©s</h3>
		<button id="hide-legend-btn">Masquer</button> <!-- üìå Bouton pour cacher -->
		<div id="legend-items"></div> <!-- üìå Contiendra les pastilles -->
		</div>
		<!-- L√©gende des composantes connexes  -->
		<div id="connected-components-legend" style="display: none;">
		<h3>Composantes connexes</h3>
		<div id="legend-items"></div>  <!--  Contiendra les pastilles -->
		</div>
	
<!-- ‚úÖ COLONNE DE DROITE (GESTION DES GRAPHES) -->
    <div id="right-panel">

		<div id="graph-management">
			<h3>Gestion des graphes</h3>
				
			<button id="store-graph-en-0" title="Enregistre le graphe affich√© (supprime l'enregistrement pr√©c√©dent)." style=" background-color: #6666ff;">STOCKER</button>
			<button id="show-stored-graph0" title="Affiche le graphe stock√©." style=" background-color: #6666ff;" >AFFICHER</button>
			<button id="store-graph-en-1" title="Enregistre le graphe affich√© (ne supprime pas l'enregistrement pr√©c√©dent)."style=" background-color: #0066ff;" >Ajouter au CUMUL</button>
			<button id="subtract-graph-en-1" title="Retire le graphe affich√© du CUMUL " style=" background-color: #0066ff;" >Soustraire du CUMUL</button>
			<button id="show-stored-graph1"style=" background-color:#0066ff;" >Afficher le CUMUL</button>
			<button id="reset-stored-graph-1"style=" background-color: #0066ff;" >Vider le CUMUL</button>
			
			<h3>Import/Export</h3>
			<button id="import-graph" title="Importe un fichier, au format JSON compatible, √† partir de votre ordinateur."  style=" background-color: #cc99ff;" >Importer un graphe</button>
			<input type="file" id="import-file" accept=".json" style="display: none;" />
			<button id="btn-importer-mots" title="Importe et affiche les mots d'un fichier, au format CSV sur votre ordinateur, contenant une liste de mots s√©par√©s par une virgule." style=" background-color: #cc99ff;" >Importer des mots</button>
			<input type="file" id="file-mots-import" accept=".csv" style="display: none;">
			
			<button id="export-graph" title="Exporte le fichier correspondant au graphe affich√©, au format JSON, dans votre dossier T√©l√©chargement." style=" background-color: #66ccff;" >Exporter le graphe</button>
			<button onclick="exportGraphToPDF()" title="Exporte le graphe tel qu'affich√© au format PDF dans votre dossier de T√©l√©chargement." style=" background-color: #66ccff;">Exporter le graphe en PDF</button>
			<button id="export-label"  title="Copie la liste des mots du graphe affich√© dans un fichier CSV de votre dossier T√©l√©chargement." style=" background-color: #66ccff;" >Exporter les mots</button>	
			<button id="export-matrix-btn" title="Cr√©ation, pour le graphe affich√©, d'un tableau dont les cases (i,j) indiquent si les mots i et j sont synonymes dans le dictionnaire de synonymie complet. Si les mots i et j sont synonymes, la case (i,j) contient 1, m√™me s‚Äôils ne sont pas reli√©s dans le graphe affich√©. S‚Äôils ne sont pas synonymes, la case contient 0."  style=" background-color: #6fa8dc;" >Exporter matrice de synonymie</button>
			<button id="export-path-btn" title="Cr√©ation, pour le graphe affich√©, d'un tableau dont les cases (i,j) contiennent la distance entre les mots i et j (nombre minimum de liens pour aller d‚Äôun mot √† un autre dans le dictionnaire complet). Si deux mots sont synonymes leur distance est 1 ; s‚Äôils sont reli√©s par un chemin de synonymie comportant 2, 3, n mots interm√©diaires, la distance est 2, 3, n. S‚Äôil n‚Äôexiste aucun lien entre eux dans le dictionnaire, la case contient -1. ATTENTION le calcul de cette matrice EST TR√àS LONG notamment si les mots sont √©loign√©s en terme de synonymie (de quelques minutes pour moins de 10 mots √† plusieurs dizaines de minutes au del√†, des heures si plus de 1000 mots) !"  style=" background-color: #6fa8dc;" >Exporter matrice des distances</button>
			<button id="stop-matrix-btn" title="Interrompt le calcul de la matrice des distances apr√®s la prochaine √©tape du calcul en cours" style="display:none; ">üõë Annuler le calcul de la matrice des distances</button>


						
		</div>	
		 		
	</div>	 
	
<!-- ‚úÖ BOUTONS EN DESSUS DU GRAPHE   -->	

<!-- ‚úÖ bouton aide -->	
	<button id="help-btn"
        style="position: fixed; top: 10px; right: 650px;left:270px; width: 60px;
               z-index: 1000; padding: 10px 16px;
               background-color: #66ccff; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Aide</button>
	
<!-- ‚úÖ contenu aide -->	
	<div id="help-modal"
     style="display: none; position: fixed; top: 15%; left:22%; width: 50%;
            background: white; border: 1px solid #ccc; padding: 20px;fontSize = "40px";
            box-shadow: 0 0 10px rgba(0,0,0,0.1); z-index: 2000;">
	<h2>Cet √©cran vous permet de visualiser, d'explorer et d'analyser</h2>
	<h2>les relations de synonymie entre des mots fran√ßais, √† l'aide de graphes.</h2>
	<p>Les mots (50352) et les relations de synonymie (212084) sont issus du <strong>D√âS (Dictionnaire √âlectronique des Synonymes)</strong></p>
	<p>mis √† disposition sur Internet par le laboratoire <a href="https://crisco4.unicaen.fr/des/" target="_blank">CRISCO</a> de l‚ÄôUniversit√© de Caen.</p>
	<p>Les <a href="https://fr.wikipedia.org/wiki/Th%C3%A9orie_des_graphes" target="_blank">graphes</a> sont des mod√®les simples de r√©seaux d'objets (ici les mots) reli√©s entre eux par une relation (ici la synonymie).</p>
	<p> - </p>
	<p>Le <strong>Graphe complet</strong> comprend tous les mots du dictionnaire.</p>
	<p>Le bouton <strong>Filtrer</strong> cr√©e un <strong>Graphe filtr√©</strong> avec les mots extraits selon les crit√®res du filtrage.</p>
	<p>Au d√©part le graphe complet est le <strong>graphe en cours</strong>, ensuite le dernier graphe filtr√© est le <strong>graphe en cours</strong>.</p>
	<p>Les traitements associ√©s aux boutons se font sur le <strong>graphe en cours</strong> sauf pour "Cliques" qui utilise le graphe complet.</p>
	<p><strong>Survoler les boutons pour en avoir une courte explication.</strong> </p>
	<p>Commencer par <strong>rechercher un mot dans le graphe en cours</strong>, ce mot sera s√©lectionn√© (vedette) et s'affichera en rouge en haut de la colone de gauche.</p>
	<p> - </p>
	<p>Avec la souris, vous pouvez : </p>
	<p><strong>Survoler</strong> les points (mots) du graphe pour afficher le nombre et la liste de leurs synonymes.</p>
	<p><strong>Cliquer gauche</strong> sur un mot pour afficher toutes ses informations dans le dictionnaire et le s√©lectionner.</p>
	<p><strong>Cliquer droit</strong> sur un mot pour afficher ses liens dans le graphe affich√©.</p>
	<p><strong>Clic gauche maintenu sur le fond du graphe</strong> pour d√©placer tout le graphe.</p>
	<p>Utiliser le <strong>zoom</strong> (molette de la souris) pour modifier la taille de l'affichage (visibilit√© des mots).</p>
				 
	<button onclick="document.getElementById('help-modal').style.display='none'" 
	style="margin-top: 10px;width: 200px;"
	>Fermer</button>   
</div>	
<!-- ‚úÖ bouton graphe complet -->	
	<button id="graphe-complet" 
	title="Fait, du graphe complet du dictionnaire, le graphe en cours mais ne l'affiche pas car trop volumineux."
	style=" position: fixed; top: 10px; right:750px; left:370px; width: 120px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Graphe complet</button>

<!-- ‚úÖ bouton Filtrer -->	
	<button id="filtre-btn"
	title="Filtre le graphe en cours (graphe complet ou dernier graphe filtr√©)"
	style=" position: fixed; top: 10px; right:450px; left:500px; width: 85px;
               z-index: 1000; padding: 10px 16px;
               background-color: #167019; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Filtrer</button>
	<div id="filter-panel" style="display: none; position: fixed; top: 90px; left: 450px; z-index: 1000;
            background: #f0f0f0; padding: 12px; border: 1px solid #ccc; border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15); width: 250px;">
	<div style="text-align: right;">
	<button id="filter-help-btn" title="Aide sur le filtrage" style="font-size: 14px; padding: 2px 6px; cursor: pointer;">
    Aide</button>
	</div>				
	<strong>Ayant au moins une de ces cat√©gories grammaticales :</strong><br>
	<div id="catgram-filters" style="margin-bottom: 10px;">
    <label><input type="checkbox" value="adj."> adj.</label><br>
    <label><input type="checkbox" value="verbe"> verbe</label><br>
    <label><input type="checkbox" value="subst."> subst.</label><br>
    <label><input type="checkbox" value="adv."> adv.</label><br>
    <label><input type="checkbox" value="part."> part.</label><br>
    <label><input type="checkbox" value="loc."> loc.</label><br>
    <label><input type="checkbox" value="pr√©p."> pr√©p.</label><br>
    <label><input type="checkbox" value="interj."> interj.</label><br>
	<label><input type="checkbox" value="autres"> Autres</label>
	</div>
	<label><strong>ET nombre minimal de synonymes :</strong></label><br>
	<input type="number" id="min-syno" value="1" min="1" max="250" style="width: 120px; height: 36px; font-size: 16px;"><br><br>
	
	<label><strong>ET nombre maximal de synonymes :</strong></label><br>
	<input type="number" id="max-syno" value="250" min="1" max="250" style="width: 120px; height: 36px; font-size: 16px;"><br><br>

	<button id="apply-filter-btn">Appliquer</button>
	<button id="close-filter-panel">Fermer</button>
</div>

<!-- ‚úÖ bouton graphe filtr√© -->	
	<button id="graphe-filtre" 
	title="Affiche le dernier graphe filtr√©."
	style=" position: fixed; top: 10px; right:300px; left:595px; width: 120px;
               z-index: 1000; padding: 10px 16px;
               background-color: #70db70; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Graphe filtr√©</button>	
	
<!-- ‚úÖ bouton  forceatlas2  -->	
	<button id="toggle-forceatlas2" style="position: fixed; top: 10px; right: 200px;left:780px; width: 150px;
               z-index: 1000; padding: 10px 16px;
               background-color: #167019; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"  title="Optimisation de la disposition spatiale du graphe affich√©" >Arr√™ter-d√©marrer la spatialisation</button>
	
<!-- ‚úÖ bouton Rafra√Æchir l'affichage  -->		
	<button id="refresh-graph-btn" 
	title="Corrige les d√©fauts de l'affichage"
	style="position: fixed; top: 10px; right: 200px;left:970px; width: 150px;
               z-index: 1000; padding: 10px 16px;
               background-color: #66ccff; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;"
	>Rafra√Æchir l'affichage</button>
	
	<!-- ‚úÖ Champ et bouton Recentrer sur le mot -->
<input type="text" id="mot-recentrage"
       placeholder="Mot du graphe"
       style="position: fixed; top: 10px; left: 1130px; width: 150px;
              z-index: 1000; padding: 8px;
              border: 1px solid #ccc; border-radius: 6px;
              box-shadow: 0 2px 6px rgba(0,0,0,0.1);"
>

<button id="recentrer-btn"
        title="Mise en √©vidence du mot saisi"
        style="position: fixed; top: 10px; left: 1290px; width: 50px;
               z-index: 1000; padding: 10px 10px;
               background-color: #66ccff; color: white;
               border: none; border-radius: 6px;
               box-shadow: 0 2px 6px rgba(0,0,0,0.1);
               cursor: pointer;">
    üîç
</button>


	
<!-- ‚úÖ info bulle au survol de noeud -->		
	<div id="node-tooltip"
	style="position: absolute;background: rgba(0, 0, 0, 0.8);color: white;
	padding: 5px;border-radius: 5px;display: none;font-size: 14px;	z-index: 1000;">				
    </div>

</div>

	

<!-- FIN DES DIV----------------------------------------------------------------------------------------------------- -->
 
 
<!-- scrip js----------------------------------------------------------------------------------------------------- -->
 <script>
 
//////////////DECLARATION GLOBALE pour une utilisation partout////////////////////////////// 

	let storedGraphComplet = null; //variable de stockage permanent du graphe complet : fichier json
	let storedGraphEncours = null; //variable de stockage du graphe en cours, initalis√© avec le graphe complet puis le graphe filtr√©
	let storedGraphfiltre = null; //variable de stockage du graphe filtr√©  
	let encours = "complet" ; //flag pour le graphe en cours
	let complet = "complet";
	let filtre = "filtre" ;
	
	let typeDeGraphe = "standard";  //  Par d√©faut
	let	isAdjacency = null ;  // graphe d adjacence
	let storedGraphLouvain = null; //variable de stockage du graphe Louvain
	
	let isForceAtlas2Running = false;
	let storedGraph0 = { nodes: [], edges: [] }; //variable de stockage du graphe  
	let storedGraph1 = { nodes: [], edges: [] };  // ‚úÖ Initialise un graphe vide
	let baseGraphForComponents = null;  // ‚úÖ Stocke le graphe de r√©f√©rence pour la d√©tection des connexes
	
	let isFirstComponentDetection = true;  // ‚úÖ V√©rifie si c'est le premier calcul des connexes
	let s; // D√©clarez `s` dans la port√©e globale pour qu'elle soit accessible dans toutes les fonctions
	let vedette = null; //stocke l'ID du noeud s√©lectionn√©
	let communityColors = {};
	let lastGraphDisplayed = null;
	let lastDisplayOptions = {};
	let forceAtlasTimeout = null;
	let lastGraphOptions = {};
	let stopMatriceCalcul = false;
	let calculInProgress = false;


//////////////FIN DECLARATION GLOBALE ////////////////////////////// 

showNotification("Patientez quelques secondes, le graphe complet est volumineux !",2000);

// Affiche l'aide automatiquement √† chaque chargement
window.addEventListener('DOMContentLoaded', () => {
  document.getElementById('help-modal').style.display = 'block';
});

setTimeout(() => {
		showNotification("Commencez par <strong><strong>Rechercher un mot dans le graphe en cours </strong> </strong> et utiliser ensuite les boutons affich√©s sur l'√©cran. ", 10000);
	},1000 );
	

//////////<!-- CHARGER LES DONN√âES INITIALES a partir de DATA.JSON -->//////
 async function loadGraph() {
      try {
			<!-- LES DONN√âES xxxxx.JSON SONT DANS LE MEME DOSSIER QUE INDEX.HTML  -- ------->
			<!-- datafinal.json  output2DES.json   outputDES_catgram.json   largedata.json      -- ------->
			const response = await fetch('largedata.json');
			const data = await response.json();

			// V√©rifier que les donn√©es contiennent les propri√©t√©s nodes et edges
			if (data && data.nodes && data.edges) {
				console.log('‚úÖLes donn√©es charg√©es contiennent bien les propri√©t√©s nodes et edges.');
			
				// CHARGEMENT PERMANENT DU GRAPHE JSON DANS STOREDGRAPHCOMPLET	
				storedGraphComplet = storeGraph(data);
				console.log('‚úÖLes donn√©es charg√©es sont copi√©es dans le graphe complet');
				
				// CHARGEMENT DU GRAPHE JSON DANS storedGraphEncours= GRAPHE EN COURS	
				storedGraphEncours = storeGraph(data);
				const nbNodes = storedGraphEncours.nodes.length;
				const nbEdges = storedGraphEncours.edges.length/2;
				encours = complet;  // flag pour marquer qui est encours
				console.log("‚úÖLes donn√©es charg√©es sont copi√©es dans le graphe en cours", data);
				
				//INITIALISATION DU GRAPHE DANS S.GRAPH SANS AFFICHAGE
				//  Cr√©ation du graphe
				// Initialiser Sigma vide	
				s = new sigma({
					graph:{
					nodes: [],
					edges: []
					},
					container: 'graph-container',
					settings: {
					drawEdges: false // rien ne s‚Äôaffiche visuellement au d√©but
					}
				});
				//chargement du json dans s.graph sans affichage (sans utiliser displaygraph)
				storedGraphEncours.nodes.forEach(node => s.graph.addNode(node));
				storedGraphEncours.edges.forEach(edge => s.graph.addEdge(edge));
				
				updateGraphStats(s.graph);
				setGraphBanner(`Graphe complet en cours : ${nbNodes} mots, ${nbEdges} liens`, "#e8f5e9");
				updateTitreGraph("Graphe complet charg√© mais non affich√©");
				
			<!-- FIN DE CHARGER LES DONN√âES INITIALE -->			
			}
			else {
				showNotification("‚ùå Fichier JSON invalide : pas de nodes ou edges");
				}			
			// Bloque le menu contextuel
			document.getElementById("graph-container").addEventListener("contextmenu", function (e)
			{e.preventDefault(); });				
		} catch (error) {
					console.error('Erreur lors du chargement du fichier JSON:', error);
					}
  } 
 /////////////////////<!-- FIN DU CHARGER LES DONN√âES INITIALES a partir de DATA.JSON  -->/////
	
	
///////////// AFFICHAGE DES GRAPHES  ///////	DISPLAYGRAPH   ///////////////////////////
function displayGraph(graphData, options = {}) {
    const defaultOptions = {
        rescale: true,
        random: false,
        showEdges: true
    };

    const finalOptions = { ...defaultOptions, ...options };
    lastGraphOptions = { ...finalOptions }; // sauvegarde l‚Äô√©tat effectif utilis√©
    const { rescale, random, showEdges } = finalOptions; 

	if (rescale) {
    rescaleGraphLayout(graphData, 0.6);
	}
    // ‚ñ∂Ô∏è Construire le graphe √† utiliser : avec ou sans les aretes
  let graphToUse;
  if (!showEdges) {
    graphToUse = {
      nodes: [...graphData.nodes],
      edges: []  // ‚úÖ on retire les ar√™tes
    };
  } else {
    graphToUse = graphData;
  } 
 if (s) {   // D√©truire l'instance actuelle de Sigma.js
  s.unbind('overNode');
  s.unbind('outNode');
  s.refresh(); // force le redraw sans survol
  s.kill();
}
	lastGraphDisplayed = graphData;
	lastDisplayOptions = options;
	const nodeCount = graphData.nodes.length  ;

  //console.log("#nodes, initialgraphe",nodeCount ,random );
//  D√âFINIR LA CAT√âGORIE DU GRAPHE
  let sizeClass = nodeCount < 100 ? "small"
                  : nodeCount <= 500 ? "medium"
                  : "big";
  console.log(" DISPLAYGRAPH Type de graphe :", sizeClass, " N≈ìuds :", nodeCount, "rescale :",rescale ); 

// redisposer aleatoirement les grands graphes sauf si random est √† true
  if ( !random && nodeCount> 500) {
	applyRandomLayout(graphData);
};
//  D√©finir les tailles des n≈ìuds pour chaque cat√©gorie de graphe
const nodeSizes = {
  small: { vedette: 12, normal: 6 },
  medium: { vedette: 8, normal: 4 },
  big: { vedette: 8, normal: 4 }
};
//  D√©finir les param√®tres d‚Äôaffichage des tailles dans Sigma
const settingsSizes = {
  small: { minNode: 2, maxNode: 16 },
  medium: { minNode: 2, maxNode: 12 },
  big: { minNode: 2, maxNode: 6 }
};
	//  V√©rifie si la vedette est pr√©sente dans ce sous-graphe
	const vedetteInGraph = vedette && graphData.nodes.some(n => n.id === vedette.id);
	//console.log ("displaygraph : vedette pr√©sente  ", vedetteInGraph, "label", vedette.label);

graphData.nodes.forEach(node => {
  // ‚ñ∂Ô∏è Couleur et taille des nodes
if (vedette && node.id === vedette.id) {
    node.color = "#e74c3c"; // üî¥ vedette
    node.size = nodeSizes[sizeClass].vedette;
  } else {
    node.size = nodeSizes[sizeClass].normal;
  }
  node.originalColor = node.color;
  // ‚ñ∂Ô∏è Sauvegarde du label original
if (!node.originalLabel) node.originalLabel = node.label;
  // ‚ñ∂Ô∏è D√©tection vedette ou voisin
  const isVedetteNode = vedette && node.id === vedette.id;
  const isNeighbor = vedette && graphData.edges.some(edge =>
    (edge.source === vedette.id && edge.target === node.id) ||
    (edge.target === vedette.id && edge.source === node.id)
  );
  
//if (graphData.nodes.length > 100 ) {
	// ‚ñ∂Ô∏è Affichage du label seulement pour vedette + voisins
	//	node.label = (isVedetteNode || isNeighbor)
	//	? node.originalLabel : " ";  // invisible visuellement, mais encore exploitable
	//}
	
});

/// Couleur et sauvegarde des ar√™tes
  graphData.edges.forEach(edge => {
    if (!edge.color) {
      edge.color = sizeClass === "big"
        ? "rgba(0, 0, 255, 0.2)"
        : "rgba(0, 0, 255, 0.6)";
    }
    if (!edge.originalColor) edge.originalColor = edge.color;
  });
 // Sauvegarde des couleurs initiales pour restauration ult√©rieure
	graphData.nodes.forEach(node => {
		if (!node.originalColor) node.originalColor = node.color;
		});
	graphData.edges.forEach(edge => {
		if (!edge.originalColor) edge.originalColor = edge.color;
		});
 //  Param√®tres Sigma adapt√©s
  const settings = {
    minNodeSize: settingsSizes[sizeClass].minNode,
    maxNodeSize: settingsSizes[sizeClass].maxNode,
    minEdgeSize: 0.4,
    maxEdgeSize: 1.2,
    font: "Arial",
    fontsize: sizeClass === "small" ? 20: (sizeClass === "medium" ? 14 : 10),
    defaultLabelColor: "#000",
	labelThreshold: 0,           // ‚úÖ tous les labels visibles m√™me sans zoom
  
  labelSize: "fixed" ,    // ou   "proportional"
  labelDensity: 1,             // 1 = 100% des labels affich√©s
  labelGridCellSize: 0         // 0 = pas de limite de densit√© spatiale
  };

// fonction pour recalibrer laffichage du graphe dans 80% du container
function rescaleGraphLayout(graphData, scale = 0.6) {
  //  R√©cup√®re les extr√™mes des coordonn√©es
  const xs = graphData.nodes.map(n => n.x);
  const ys = graphData.nodes.map(n => n.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const rangeX = maxX - minX;
  const rangeY = maxY - minY;
  const maxRange = Math.max(rangeX, rangeY);
  //  Applique un zoom centrant et r√©ducteur sur tous les n≈ìuds
  graphData.nodes.forEach(node => {
    node.x = ((node.x - centerX) / maxRange) * scale;
    node.y = ((node.y - centerY) / maxRange) * scale;
  });
}
function applyRandomLayout(graphData, range = 1) {
  graphData.nodes.forEach(node => {
    node.x = (Math.random() - 0.5) * range;
    node.y = (Math.random() - 0.5) * range;
  });
}
//  Cr√©ation du graphe
    s = new sigma({
      graph: graphToUse,
      container: 'graph-container',
      settings: settings
    });
s.unbind('clickNode');  // ‚úÖ emp√™che les doublons
ClicNodeEvents(s); // r√©attache les clics apr√®s recr√©ation du graphe
	
	// ‚úÖ transf√©rer la balise dans l'objet s.graph
	s.graph.isAdjacency = graphData.isAdjacency || false;
	
    s.refresh();
	
	//affiche les stats
		updateGraphStats(graphData);	   
	// survol des noeuds
		SurvolNoeud(s);  
	// Afficher des informations au clic gauche des n≈ìuds
		s.unbind('clickNode');  // ‚úÖ emp√™che les doublons
		ClicNodeEvents(s);
	// Afficher des informations au clic droit des n≈ìuds	 
		RightClickNodeEvents(s); 
  }
//////////// FIN FONCTION POUR AFFICHER UN GRAPHE  

////BANNIERE = TITRE DES GRAPHES  	
function setGraphBanner(text, color = "#f0f0f0") {
  const banner = document.getElementById("graph-title-banner");
  if (banner) {
    banner.textContent = `${text}`;
    banner.style.backgroundColor = color;
  }
}
////FIN BANNIERE

//AFFICHAGE STATS (nbre points et aretes) coin haut gauche du cadre du graphe
function updateGraphStats() {
    const visibleNodes = s.graph.nodes().filter(node => !node.hidden);
    const visibleEdges = s.graph.edges().filter(edge => !edge.hidden);
    const nbNodes = visibleNodes.length;
    const nbEdges = visibleEdges.length;
   
	const isReduit = s.graph.type === "reduit"; // si tu utilises un flag type
    const vraiNbEdges = isReduit ? nbEdges : nbEdges / 2;
 
	const statsDiv = document.getElementById("graph-stats-display");
    statsDiv.textContent = `${nbNodes} mot${nbNodes > 1 ? 's' : ''}, ${vraiNbEdges} lien${vraiNbEdges > 1 ? 's' : ''}`;
}
// FIN AFFICHAGE STATS 

//AFFICHAGE TITRE du graphe = NOM du bouton √† droite des stat
function updateTitreGraph(titre) { 
	const TitreDiv = document.getElementById("graph-titre-display");
    if (TitreDiv) {
    TitreDiv.textContent = titre;
	}
}
// FIN AFFICHAGE TITRE 


///MESSAGES √Ä L'UTILISATEUR //////

///MESSAGES √Ä DUR√âE D√âTERMIN√âE 	 par option
	function showNotification(message, duration = 3000) {
  const notif = document.getElementById("notification");
  if (!notif) return;

  notif.innerHTML = message;           // ‚úÖ Permet le HTML enrichi
  notif.style.display = "block";       // ‚úÖ Affiche la notification
  notif.style.opacity = "1";           // Facultatif : effet fondu possible

  // ‚úÖ Annule tout pr√©c√©dent timeout pour √©viter les conflits
  if (notif.dismissTimeout) {
    clearTimeout(notif.dismissTimeout);
  }

  notif.dismissTimeout = setTimeout(() => {
    notif.style.display = "none";
  }, duration);
}

///MESSAGES AVEC BOUTON "FERMER" INCORPOR√â
	function showNotif(message) {
	const notif = document.getElementById("graph-message");
	if (notif) {
    notif.innerHTML = `
      <div style="text-align: right;">
        <button onclick="document.getElementById('graph-message').style.display='none'"
                style="padding: 4px 10px; background:#ccc; border:none; border-radius:4px;">
          Fermer
        </button>
      </div>
      ${message}
    `;
    notif.style.display = "block"; 
	makeDraggable(notif);  // active le drag
  }
}

////fin MESSAGES ////////////
  
   // Charger le graphe lorsque la page est pr√™te
    window.onload = loadGraph;
		
<!-- BOUTONS VERTS AU DESSUS DU GRAPHE  -->

///// Ô∏è Activation du panneau d'AIDE au clic sur le bouton "Aide"
document.getElementById("help-btn").addEventListener("click", () => {
  const helpModal = document.getElementById("help-modal");
  if (helpModal) {
    helpModal.style.display = "block";
  }
});
///// FIN Activation du panneau d'AIDE au clic sur le bouton "Aide"

//  bouton "GRAPHE COMPLET" 
//  affichage invisible du graphe complet stock√© dans storedGraphComplet au chargement json
	document.getElementById('graphe-complet').addEventListener('click', function () {
	
	if (encours === complet ) { 
	console.log("encours =", encours);
	showNotification("‚ö†Ô∏è le graphe complet est d√©j√† le graphe encours.");
	return ; 
	}
	
  showNotification("Patientez quelques secondes, le graphe complet est volumineux !");

  setTimeout(() => {
    // ‚úÖ Vide le graphe actuel pour √©viter doublons
    s.graph.clear();
	s.refresh();

    // ‚úÖ Recharge les donn√©es compl√®tes sans affichage visible
    storedGraphComplet.nodes.forEach(node => s.graph.addNode(node));
    storedGraphComplet.edges.forEach(edge => s.graph.addEdge(edge));

    // ‚úÖ Mise √† jour des r√©f√©rences
    storedGraphEncours = storeGraph(storedGraphComplet); // complet devient encours 
	encours = complet ; //flag de qui est encours
    storedGraphfiltre = null;

	updateGraphStats(s.graph);
	
    const nbNodes = storedGraphEncours.nodes.length;
	const nbEdges = storedGraphEncours.edges.length;
    setGraphBanner(`Graphe complet en cours : ${nbNodes} mots, ${nbEdges} liens`, "#e8f5e9");

    // ‚ùå Ne pas appeler s.refresh() ici = pas d‚Äôaffichage visuel
    // ‚ùå Ne pas appeler displayGraph()
    // ‚úÖ Le graphe est pr√™t en m√©moire

  }, 200);
  
 updateTitreGraph("Graphe Complet charg√© ");
  
});
// FIN  du bouton "GRAPHE COMPLET" 	

//BOUTON FILTRER
document.getElementById('filtre-btn').addEventListener('click', function () {
  const panel = document.getElementById('filter-panel');
  panel.style.display = (panel.style.display === "none") ? "block" : "none";
});

document.getElementById('apply-filter-btn').addEventListener('click', function () {
  const panel = document.getElementById('filter-panel');
  panel.style.display = "none";
  const selectedKeywords = Array.from(
  document.querySelectorAll('#catgram-filters input[type="checkbox"]:checked')
  ).map(input => input.value);
 // console.log("‚úÖ Cat√©gories coch√©es :", selectedKeywords);

  const minSyno = parseInt(document.getElementById('min-syno').value, 10) || 0;
  
  const maxSyno = parseInt(document.getElementById('max-syno').value, 10) || 0;
  
  const standardKeywords = ["adj.", "verbe", "subst.", "adv.", "part.", "loc.", "pr√©p.", "interj."];
  const allowedNodeIds = new Set();
  const nodes = storedGraphEncours.nodes.filter(n => {
  const hasSyno = (n["nombre de synonymes"] || 0) >= minSyno && (n["nombre de synonymes"] || 0) <= maxSyno ;
  //console.log("hasSyno=",hasSyno);
    let matchCatgram = true;
    if (selectedKeywords.length > 0) {
      const matchStandard = (n.catgram || []).some(cat =>
        selectedKeywords.some(keyword =>keyword !== "autres" && cat.includes(keyword)) );
      const matchAutres = selectedKeywords.includes("autres") &&
        !(n.catgram || []).some(cat => standardKeywords.some(std => cat.includes(std)) );
   //   if (matchAutres) {console.log("üéØ AUTRES :", n.label, "‚Üí", n.catgram); }
      matchCatgram = matchStandard || matchAutres;
    }
    const keep = hasSyno && matchCatgram;
    if (keep) allowedNodeIds.add(n.id);
    return keep;
  });

  const edges = storedGraphEncours.edges.filter(e =>
    allowedNodeIds.has(e.source) && allowedNodeIds.has(e.target)
  );
  storedGraphfiltre = { nodes, edges };
  storedGraphEncours = storeGraph(storedGraphfiltre); // devient le graphe actif
  
  displayGraph(storedGraphfiltre, { filtregraph: true });
  startForceAtlas2(storedGraphfiltre, 100);
  const nbNodes = storedGraphEncours.nodes.length; 
  const nbEdges = storedGraphEncours.edges.length; 
  setGraphBanner(`Graphe filtr√© en cours : ${nbNodes} mots, ${nbEdges/2} liens`, "#e8f5e9");
  //showNotification(`${nodes.length} mots, ${edges.length / 2} liens.`);
  encours = filtre ; //flag pour qui est encours
  updateTitreGraph("Graphe filtr√© affich√©");
  
});

document.getElementById('close-filter-panel').addEventListener('click', function () {
  document.getElementById('filter-panel').style.display = "none";
});

document.getElementById('filter-help-btn').addEventListener('click', function () {
  showNotif (`
  <strong> Aide sur le filtrage </strong><br>
  ‚Ä¢ Le filtrage, du graphe en cours, se fait sur trois conditions appliqu√©es en m√™me temps : la cat√©gorie grammaticale (catgram), le nombre minimum de synonymes et le nombre maximum de synonymes.<br>
  ‚Ä¢ Cochez une ou plusieurs cat√©gories grammaticales pour afficher les mots qui contiennent au moins une de ces cat√©gories dans leurs attributs.<br>
  ‚Ä¢ Les mots peuvent appartenir √† plusieurs cat√©gories (ex. "adj." et "subst.").<br>
  ‚Ä¢ La case <em>Autres</em> s√©lectionne les mots hors des cat√©gories explicites.<br>
  ‚Ä¢ Si aucune cat√©gorie n‚Äôest coch√©e, seuls les seuils sur les nombres de synonymes sont appliqu√©s.
  `);
});
//FIN bouton FILTRER

//  BOUTON "GRAPHE FILTRE" 
//  affiche le graphe stock√© dans storedGraphfiltre
    document.getElementById('graphe-filtre').addEventListener('click', function() {
	if (storedGraphfiltre && storedGraphfiltre.nodes.length > 0 ) { // && storedGraphfiltre.edges.length > 0) { 
		displayGraph (storedGraphfiltre, { filtregraph: true, });
		startForceAtlas2(storedGraphfiltre, 200);
		encours = filtre ; //flag pour qui est encours
		console.log ("encours =",encours);
		updateTitreGraph("Graphe filtr√©");
	} else {
		showNotification('‚ö†Ô∏è Pas de graphe filtr√©, le graphe complet est en cours.');
		}
	});
// FIN  du bouton "GRAPHE filtr√©" 	

//RAFRAICHIR pour effacer les traces des survols
document.getElementById("refresh-graph-btn").addEventListener("click", () => {
  if (!s) return;

  // ‚ñ∂Ô∏è √âtape 1 : stocker une copie propre du graphe affich√©
  const refreshedGraph = storeGraph(s.graph); //  utilise ta fonction de clonage Graphology

  // ‚ñ∂Ô∏è √âtape 2 : d√©truire compl√®tement l‚Äôaffichage actuel
 // s.kill(); ne marche pas
  //document.getElementById("graph-container").innerHTML = "";

  // ‚ñ∂Ô∏è √âtape 3 : r√©afficher le graphe stock√© √† l‚Äôidentique
  displayGraph(refreshedGraph, { rescale: false });
  setTimeout(() => {
    startForceAtlas2(s);
    setTimeout(() => s.stopForceAtlas2(s), 1000); //   dur√©e √† adapter
  }, 100); // l√©ger d√©lai pour laisser Sigma se r√©initialiser
});
//FIN de RAFRAICHIR

/// RECENTRER LE GRAPHE AFFICH√â SUR UN MOT 
document.getElementById("recentrer-btn").addEventListener("click", function() {
    const mot = document.getElementById("mot-recentrage").value.trim().toLowerCase();
    if (!mot) {
        showNotification("‚ö†Ô∏è Veuillez entrer un mot pour le mettre en √©vidence.");
        return;
    }

    const node = s.graph.nodes().find(n => n.label && n.label.toLowerCase() === mot);

    if (!node) {
        showNotification(`‚ùå Le mot "${mot}" n'est pas pr√©sent dans le graphe affich√©.`);
        return;
    }

    if (typeof node.x !== "number" || typeof node.y !== "number") {
        showNotification(`‚ùå Coordonn√©es invalides pour le n≈ìud "${node.label}".`);
        return;
    }

    // Sauvegarder couleur et taille d'origine
    const originalColor = node.color;
    const originalSize = node.size;

    // Masquer temporairement les labels des autres n≈ìuds
    s.graph.nodes().forEach(n => {
        if (n.id !== node.id) {
            n.hiddenLabel = n.label; // sauvegarde
            n.label = ""; // masque
        }
    });

    // Mettre en √©vidence le n≈ìud s√©lectionn√©
    node.color = '#e74c3c'; // rouge
    node.size = originalSize * 3;

    s.refresh();
    showNotification(`‚úÖ Le mot "${node.label}" est mis en √©vidence.`);

    // R√©tablir apr√®s d√©lai
    setTimeout(() => {
        node.color = originalColor;
        node.size = originalSize;
        s.graph.nodes().forEach(n => {
            if (n.hiddenLabel !== undefined) {
                n.label = n.hiddenLabel;
                delete n.hiddenLabel;
            }
        });
        s.refresh();
        showNotification(`üîπ Mise en √©vidence termin√©e pour "${node.label}".`);
    }, 2500); // 2,5 secondes
});


///fin  RECENTRER LE GRAPHE AFFICH√â SUR UN MOT 



<!-- BOUTONS COLONNE GAUCHE DE LA PAGE  -->	

//// üîç RECHERCHE D'UN NOEUD DANS LE GRAPHE EN COURS////////////////////////////////////////////
	document.getElementById("search-node-btn").addEventListener("click", function() {
    let searchTerm = document.getElementById("node-search").value.toLowerCase().trim();
    let resultsContainer = document.getElementById("search-results");
    resultsContainer.innerHTML = "";  // ‚úÖ Efface les r√©sultats pr√©c√©dents
    let foundNodes = storedGraphEncours.nodes.filter(node => node.label.toLowerCase().includes(searchTerm));

    if (foundNodes.length > 0) {
	
	showNotification(`Recherche et s√©lection du mot en cours.`);
        foundNodes.forEach(node => {
            let listItem = document.createElement("li");
            listItem.innerHTML = `<strong>${node.label}</strong>`;
            listItem.style.cursor = "pointer";
            listItem.style.padding = "5px";
            listItem.style.borderBottom = "1px solid #ddd";    
			listItem.addEventListener("click", function() {
				highlightNode(node.id);  // ‚úÖ Met en √©vidence le n≈ìud s√©lectionn√©
				selectedNodeId = node.id;  // ‚úÖ Stocke l'ID du n≈ìud s√©lectionn√©		
				vedette = node  ;     // ‚úÖ Stocke le n≈ìud s√©lectionn√© via recherche
				console.log("üìå Noeud s√©lectionn√© via recherche dans graphe affich√© :", vedette);

// V√©rifie si le n≈ìud est pr√©sent dans le graphe affich√© (s)
let nodeInDisplayedGraph = s.graph.nodes().find(n => n.id === node.id);
if (!nodeInDisplayedGraph) {
    showNotification(`‚ö†Ô∏è Le mot "${node.label}" est dans le graphe en cours mais pas dans le graphe affich√©.`);
}
			//  Affichage du nom de la vedette dans info-text
			var infoText = document.getElementById('info-text');
			infoText.innerHTML = `<strong style="font-size: 18px; color: red;">${vedette.label}</strong>`;

			var infoHTML = `
				<p><strong style="font-size: 12px; " > <strong style="font-size: 22px; font-weight: bold; color:red ">${vedette.label}</strong></p>
				<p><strong style="font-size: 12px; " >Informations dans le dictionnaire complet :</strong></p>	
				<p>Variantes: ${node.variantes?.join(', ') || 'Aucune'}</p>
				<p>Catgram: ${node.catgram?.join(', ') || 'Aucun'}</p>
				<p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
				<p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>
				<p>Antonymes: ${node.antonymes?.join(', ') || 'Aucun'}</p>
				<p>Cliques:<br> ${node.cliques?.map(clique => clique.join(', ').replace(/;/g, ';<br>')).join('<br>') || 'Aucune'}</p>
 
				<!--<p>Liste10: ${node.liste10?.map(item => item.map(subItem =>	subItem.join(': ')).join(', ')).join('; ') || 'Aucune'}</p>	-->
				`;
				
			//affichage du popup avec toutes les infos du node
			showNotif(infoHTML);
							
			// ‚úÖ ACTIVE LES BOUTONS
				document.getElementById("show-neighbors-btn").disabled = false; 
				document.getElementById("show-cliques-btn").disabled = false;
				document.getElementById("show-syno2-btn").disabled = false;
				document.getElementById("show-adjacency-btn").disabled = false;  
			resultsContainer.innerHTML = "";  // ‚úÖ Masque la liste apr√®s s√©lection
            });
            resultsContainer.appendChild(listItem);
        });
    } else {
        resultsContainer.innerHTML = "<li>‚ùåAucun mot trouv√©.</li>";
    }
});

//////////SURLIGNE
	function highlightNode(nodeId) {
    s.graph.nodes().forEach(node => {
        node.color = (node.id === nodeId) ? "#e74c3c" : "#3498db"; // üî¥ Rouge pour le n≈ìud trouv√©, üîµ Bleu pour les autres
		node.size = (node.id === nodeId) ? 30 : 8 ;
    });
///////FIN DE SURLIGNE	
	
	//  V√©rifier si un graphe est affich√©  
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
        return; // cas du graphe complet non affich√© invisible
    }
	else{
	    s.refresh();  // ‚úÖ Met √† jour l'affichage du graphe
	}
}
//// FIN de RECHERCHE D'UN NOEUD DANS LE GRAPHE AFFICH√â////////////////////// 

//////////// GRAPHE DES SYNONYMES = VOISINS de la vedette /////////// 
document.getElementById("show-neighbors-btn").addEventListener("click", function () {
  if (!vedette) {
    showNotification("‚ùå Aucun mot s√©lectionn√© !");
    return;
  }
	// console.log("üìågraphe des voisins pour la vedette :", vedette.label);
  // ‚úÖ Filtrer toutes les ar√™tes contenant le n≈ìud s√©lectionn√©
  let subGraphEdges = storedGraphEncours.edges.filter(
  edge => edge.source === vedette.id || edge.target === vedette.id  );
  // ‚úÖ Extraire les n≈ìuds impliqu√©s dans ces ar√™tes
  let neighborIds = new Set();
  subGraphEdges.forEach(edge => {
    neighborIds.add(edge.source);
    neighborIds.add(edge.target);
  });
    
  // ‚úÖ Inclure les n≈ìuds du graphe initial
  let subGraphNodes = storedGraphEncours.nodes.filter(node => neighborIds.has(node.id));

	let subGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	
	// ‚úÖ V√©rification dans la console avant affichage
    //console.log("üìå Sous-graphe Syno1 g√©n√©r√© :", { nodes: subGraphNodes, edges: subGraphEdges });
   
    // #e74c3c üî¥ Rouge pour la vedette bleu les autres   	
	// ‚úÖ Appliquer les couleurs pour forcer vedette rouge, autres en bleu
	subGraphNodes.forEach(node => {
	node.color = (node.id === vedette.id) ? "#e74c3c" : "#3498db";
	});
		 
	// ‚úÖ Message si aucun synonyme
	if (subGraphEdges.length === 0) {
		showNotification("‚ùå Aucun synonyme trouv√© dans le graphe en cours.");
		} ;
		
	// ‚úÖ Afficher le sous-graphe
	displayGraph(subGraph);
	setTimeout(() => {
			startForceAtlas2(subGraph,100);	
			const camera = s.camera;
			const zoomRatio = 0.8; // >1 pour zoomer, <1 pour d√©zoomer
			camera.goTo({
				ratio: camera.ratio / zoomRatio  
				});	
		}, 200); // petit d√©lai pour garantir que s est pr√™t
	
		updateTitreGraph("Graphe Synonymes 1");
	
});
//// FIN DE CALCUL ET AFFICHAGE DU GRAPHE DES SYNONYMES 
  
//// Graphe ADJACENCE /////////////////////////////////////////////
document.getElementById("show-adjacency-btn").addEventListener("click", function () {
    generateAdjacencyGraph(vedette);
});

function generateAdjacencyGraph(vedette) {
    if (!vedette) {
        showNotification("‚ùå Aucun mot s√©lectionn√© !");
        return;
    }
    //console.log("üìå G√©n√©ration du graphe d'adjacence pour :", vedette);
    // ‚úÖ √âtape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphEncours.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });
    // ‚úÖ √âtape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphEncours.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });
    // ‚úÖ √âtape 3 : Construire le sous-graphe Syno2
    let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);
    let subGraphNodes = storedGraphEncours.nodes.filter(node => allSyno2Nodes.has(node.id));

    // ‚úÖ Cr√©er un Set des IDs des n≈ìuds valides pour √©viter l'erreur
    let validNodeIds = new Set(subGraphNodes.map(node => node.id));

    // ‚úÖ Filtrer les ar√™tes pour ne garder que celles qui connectent des n≈ìuds existants
    let subGraphEdges = storedGraphEncours.edges.filter(edge =>
        validNodeIds.has(edge.source) && validNodeIds.has(edge.target) );

    // ‚úÖ √âtape 4 : Garder uniquement `vedette` et ses voisins directs **avec leurs connexions**
    let adjacencyNodes = new Set([...level1Neighbors, vedette.id]);  // ‚úÖ On garde `vedette` et ses voisins directs
    let finalNodes = storedGraphEncours.nodes.filter(node => adjacencyNodes.has(node.id));  // ‚úÖ R√©cup√©rer les n≈ìuds valides

    let finalEdges = subGraphEdges.filter(edge =>  // ‚úÖ V√©rification suppl√©mentaire pour √©viter les erreurs
        adjacencyNodes.has(edge.source) && adjacencyNodes.has(edge.target) );
     
	let adjacencyGraph = {
    nodes: finalNodes,
    edges: finalEdges,
    isAdjacency: true // ‚úÖ balise int√©gr√©e
	};
    console.log("üìå Graphe d'adjacence g√©n√©r√© :", adjacencyGraph);

    // ‚úÖ V√©rification avant affichage
    //console.log("üìå V√©rification des n≈ìuds :", adjacencyGraph.nodes);
    //console.log("üìå V√©rification des ar√™tes :", adjacencyGraph.edges);
	console.log("üìå V√©rification de length :", adjacencyGraph.edges.length);

	// ‚úÖ Message si aucun synonyme
	if (adjacencyGraph.edges.length === 0) {
		showNotification("‚ùå Aucun synonyme trouv√© dans le graphe en cours.");
		} 
		else {
		// ‚úÖ AFFICHER LE GRAPHE D'ADJACENCE
		displayGraph(adjacencyGraph);
		setTimeout(() => {
			startForceAtlas2(adjacencyGraph,100);	
			const camera = s.camera;
			const zoomRatio = 0.8; // >1 pour zoomer, <1 pour d√©zoomer
			camera.goTo({
				ratio: camera.ratio / zoomRatio  
				});	
		}, 200); // petit d√©lai pour garantir que s est pr√™t

	updateTitreGraph("Graphe Adjacence");
		
		};

    // ‚úÖ Supprimer l‚Äôancien bouton s‚Äôil existe d√©j√†
    const existingBtn = document.getElementById("remove-vedette-links-btn");
    if (existingBtn) existingBtn.remove();

    // ‚úÖ Cr√©er dynamiquement le bouton
    const btn = document.createElement("button");
    btn.id = "remove-vedette-links-btn";
    btn.textContent = "Adjacence sans liens avec la vedette";
    btn.classList.add("hide-vedette-edges-btn");
    
	btn.style.height = "15px";
	btn.style.width = "200px";
	btn.style.marginTop = "1px"; /* ‚úÖ  espace au-dessus du bouton */
	btn.style.fontSize = "11px";
    btn.style.backgroundColor = "#ffd9b3";
    btn.style.color = "black";
    btn.style.border = "none";
    btn.style.padding = "2px";
    btn.style.borderRadius = "5px";
    btn.style.cursor = "pointer";

    document.getElementById("info-buttons").appendChild(btn);

    btn.addEventListener("click", function () {
        const edgesToRemove = s.graph.edges().filter(edge =>
            edge.source === vedette.id || edge.target === vedette.id
        );
        edgesToRemove.forEach(edge => {
            s.graph.dropEdge(edge.id);
        });		 
        s.refresh();
		  // ‚úÖ Mettre √† jour les statistiques apr√®s suppression
		updateGraphStats({
			nodes: s.graph.nodes(),
			edges: s.graph.edges()
		}); 
        showNotif(` ‚úÖ Liens avec "${vedette.label}" supprim√©s.`);
        btn.remove(); // ‚úÖ Dispara√Æt apr√®s usage
    });
}
//// FIN Graphe ADJACENCE //////////////////////////////////

////FONCTION POUR CALCULER ET AFFICHER LE GRAPHE DES SYNO1 ET SYNO2 D'UNE VEDETTE
document.getElementById("show-syno2-btn").addEventListener("click", function() {
    if (!vedette) {
        showNotification("‚ùå Aucun mot s√©lectionn√© !");
        return;
    }
	//console.log("üìå G√©n√©ration du graphe des SYNO2 pour :", vedette);

    // ‚úÖ √âtape 1 : Trouver les voisins directs (niveau 1)
    let level1Neighbors = new Set();
    storedGraphEncours.edges.forEach(edge => {
        if (edge.source === vedette.id) level1Neighbors.add(edge.target);
        if (edge.target === vedette.id) level1Neighbors.add(edge.source);
    });
    // ‚úÖ √âtape 2 : Trouver les voisins des voisins (niveau 2)
    let level2Neighbors = new Set();
    level1Neighbors.forEach(neighborId => {
        storedGraphEncours.edges.forEach(edge => {
            if (edge.source === neighborId && edge.target !== vedette.id) level2Neighbors.add(edge.target);
            if (edge.target === neighborId && edge.source !== vedette.id) level2Neighbors.add(edge.source);
        });
    });
   // ‚úÖ √âtape 3 : Construire le sous-graphe "syno2"
let allSyno2Nodes = new Set([...level1Neighbors, ...level2Neighbors, vedette.id]);

// ‚ñ∂Ô∏è Cr√©ation des n≈ìuds du sous-graphe avec couleur selon niveau
let subGraph  = { nodes: [], edges: [] };
allSyno2Nodes.forEach(nodeId => {
    const originalNode = storedGraphEncours.nodes.find(n => n.id === nodeId);
    if (originalNode) {
        let color = "#000000"; // couleur par d√©faut
        if (nodeId === vedette.id) color = "#FFD700"; // vedette : jaune
        else if (level1Neighbors.has(nodeId)) color = "#1f77b4"; // niveau 1 : bleu
        else if (level2Neighbors.has(nodeId)) color = "#ff7f0e"; // niveau 2 : orange
        subGraph.nodes.push({
            ...originalNode,
            color: color
        });
    }
});
// ‚ñ∂Ô∏è Ajouter les ar√™tes entre les n≈ìuds du sous-graphe
storedGraphEncours.edges.forEach(edge => {
    if (allSyno2Nodes.has(edge.source) && allSyno2Nodes.has(edge.target)) {
        subGraph.edges.push({ ...edge });
    }
});
// ‚úÖ Message si aucun synonyme
	if (subGraph.edges.length === 0) {
		showNotification("‚ùå Aucun synonyme trouv√© dans le graphe en cours.");
		s.graph.clear();  // ‚úÖ Effacer l'affichage du graphe
		} 
		else {	
		// ‚úÖ Afficher le sous-graphe "syno 1 et 2"
		displayGraph( subGraph, { rescale: 0.6 } );
		setTimeout(() => {
			startForceAtlas2(subGraph,100);	
			const camera = s.camera;
			const zoomRatio = 0.8; // >1 pour zoomer, <1 pour d√©zoomer
			camera.goTo({
				ratio: camera.ratio / zoomRatio  
				});	
		}, 200); // petit d√©lai pour garantir que s est pr√™t
		
		updateTitreGraph("Graphe Synonymes 1 et 2");
		}		
});
////FIN fonction GRAPHE SYNO1 ET SYNO2 D'UNE VEDETTE

//CLIQUES//////////////////////////////////////////////////////:::
document.getElementById("show-cliques-btn").addEventListener("click", function () {
	if (encours === complet ) {
	showCliqueListPopup(vedette);     // ‚úÖ ouvre le popup seulement si encours= complet 
	}
	else {
	showNotification("‚ö†Ô∏è Pour afficher les cliques d'un mot, le graphe en cours doit √™tre le graphe complet.");
	return;
	}
	
	generateAdjacencyGraph(vedette);  // ‚úÖ  affichage du graphe adjacence 
	isAdjacency = true;	
	
});
// Set global pour suivre quelles cliques sont surlign√©es
let highlightedCliques = new Set();

function toggleCliqueHighlight(cliqueWords, cliqueIndex) {
    // Trouver les nodeId correspondant aux mots de la clique
    let cliqueNodeIds = s.graph.nodes()
        .filter(n => cliqueWords.includes(n.label))
        .map(n => n.id);
    // Trouver les ar√™tes entre ces n≈ìuds
    let cliqueEdgeIds = s.graph.edges()
        .filter(e => cliqueNodeIds.includes(e.source) && cliqueNodeIds.includes(e.target))
        .map(e => e.id);
		const symbol = document.getElementById(`clique-symbol-${cliqueIndex}`);
    if (highlightedCliques.has(cliqueIndex)) {
        // D√©surligner
        cliqueNodeIds.forEach(id => {
            let node = s.graph.nodes(id);
             if (node) {
            if (node.originalColor) node.color = node.originalColor;
            node.isClique = false; // ‚úÖ d√©sactive le flag
			}
        });
        cliqueEdgeIds.forEach(id => {
            let edge = s.graph.edges(id);
             if (edge) {
            if (edge.originalColor) edge.color = edge.originalColor;
            edge.isClique = false; // ‚úÖ d√©sactive le flag
        }
        });
        highlightedCliques.delete(cliqueIndex);	
	// ‚úÖ Changer la pastille en vert
        if (symbol) symbol.style.backgroundColor = "green";				
    } else {
        // Surligner
        cliqueNodeIds.forEach(id => {
            let node = s.graph.nodes(id);
            if (node) {
                 if (!node.originalColor) node.originalColor = node.color;
            node.color = "#ff1493"; // ou autre couleur
            node.isClique = true;  // ‚úÖ flag pour indiquer qu'il appartient √† une clique
            }
        });
        cliqueEdgeIds.forEach(id => {
            let edge = s.graph.edges(id);
            if (edge) {
                if (!edge.originalColor) edge.originalColor = edge.color;
            edge.color = "#ff1493";
            edge.isClique = true;  // ‚úÖ flag pour indiquer qu'elle appartient √† une clique
            }
        });
        highlightedCliques.add(cliqueIndex);		
	 // ‚úÖ Changer la pastille en rouge
        if (symbol) symbol.style.backgroundColor = "red";	
    }
    s.refresh();
}
function showCliqueListPopup(node) {
    // ‚úÖ Supprime un popup pr√©c√©dent si d√©j√† affich√©
    let oldPopup = document.getElementById("clique-popup");
    if (oldPopup) oldPopup.remove();

    // ‚úÖ Cr√©e le nouveau popup
    let popup = document.createElement("div");
    popup.id = "clique-popup";
    popup.style.position = "fixed";
    popup.style.top = "100px";
    popup.style.left = "12px";
	popup.style.height = "628px"; // hauteur fixe de 625px pour masquer la colonne gauche
	popup.style.width = "220px";
    popup.style.background = "white";
    popup.style.border = "1px solid black";
    popup.style.padding = "10px";
    popup.style.zIndex = "9999";
    popup.style.maxHeight = "630px";
    popup.style.overflowY = "auto";
    popup.style.boxShadow = "0 2px 10px rgba(0,0,0,0.2)";
	popup.innerHTML = `<h4>${node.cliques.length} cliques de : <strong><font color="red" size="+2">${node.label}</font></strong></h4>`;

// ‚úÖ Ins√©rer ici le BOUTON EFFACER
	let effacerBtn = document.createElement("button");
	effacerBtn.textContent = "Effacer le hors cliques";
	effacerBtn.style.display = "block";
	effacerBtn.style.margin = "10px 0";
	effacerBtn.addEventListener("click", function () {
     if (isAdjacency) {
        console.log("‚úÖ Le graphe affich√© est l'adjacence.");
		// Masquer tous les n≈ìuds NON dans une clique
		s.graph.nodes().forEach(node => {
        node.hidden = !node.isClique; });// ‚úÖ masque si n'appartient pas √† une clique
		//affiche les stats
		updateGraphStats(s.graph);
		s.refresh(); 
		} else {
        console.log("‚ùå Ce n'est pas l'adjacence.");
        showNotification("‚ùå Le graphe a chang√©. Le panneau Cliques est ferm√©.");
        popup.remove();
        return;
		}
});
popup.appendChild(effacerBtn);

// BOUTON REAFFICHER TOUT
let reafficherBtn = document.createElement("button");
reafficherBtn.textContent = "R√©afficher tout";
reafficherBtn.style.display = "block";
reafficherBtn.style.margin = "10px 0";
reafficherBtn.addEventListener("click", function () {
    if (isAdjacency) {
        console.log("‚úÖ Le graphe affich√© est l'adjacence.");    
	  // R√©afficher tous les n≈ìuds
    s.graph.nodes().forEach(node => { node.hidden = false;});
    // R√©afficher toutes les ar√™tes
    s.graph.edges().forEach(edge => {edge.hidden = false;});	
	//affiche les stats
	updateGraphStats(s.graph);	
    s.refresh();
} else {
        console.log("‚ùå Ce n'est pas l'adjacence.");
        showNotification("‚ùå Le graphe a chang√©. Le panneau Cliques est ferm√©.");
        popup.remove();
        return;
    }
});
popup.appendChild(reafficherBtn);
  // ‚úÖ Puis la liste des cliques
  node.cliques.forEach((clique, index) => {
    let item = document.createElement("div");      
	item.innerHTML = `
    <span class="clique-symbol" id="clique-symbol-${index}" data-index="${index}"></span> 
    C${index + 1}: ${clique.join(', ')}
	`;		
    item.querySelector(".clique-symbol").addEventListener("click", () => {
    toggleCliqueHighlight(clique, index);});	 
    popup.appendChild(item);
    });	
	function extractCliqueSubgraph(cliqueLabels) {
	const base = storedGraphEncours;  // graphe structurel complet
	const labelToId = new Map(base.nodes.map(n => [n.label, n.id]));
	const cliqueNodeIds = cliqueLabels.map(l => labelToId.get(l)).filter(Boolean);
	const nodes = base.nodes.filter(n => cliqueNodeIds.includes(n.id));
	const nodeIdSet = new Set(nodes.map(n => n.id));
	const edges = base.edges.filter(e =>
    nodeIdSet.has(e.source) && nodeIdSet.has(e.target)
	);
	return { nodes, edges };
	}	
	function rebuildGraphFromSurlignedCliques() {
	const base = storedGraphEncours;  // graphe structurel complet
	const cliqueLabels = s.graph.nodes()
    .filter(n => n.isClique)
    .map(n => n.label);
	return extractCliqueSubgraph(cliqueLabels);
	}
//BOUTON FERMER MENU CLIQUES
    let closeBtn = document.createElement("button");
    closeBtn.textContent = "Fermer";
    closeBtn.addEventListener("click", () => {
		popup.remove();
		if (Array.from(highlightedCliques).length >  0) {			
			const rebuilt = rebuildGraphFromSurlignedCliques();
			displayGraph(rebuilt, { random: false });
		} else {
		console.log("vedette des cliques", vedette);
		highlightedCliques.clear();
		storedGraphEncours = storeGraph(storedGraphComplet); // ‚úÖ base compl√®te
		generateAdjacencyGraph(vedette);// ‚úÖ Revient √† l‚Äôadjacence normale
     	}
	});  
    popup.appendChild(closeBtn);	
    document.body.appendChild(popup);
}
//fin CLIQUES

// FONCTION POUR LANCER PUIS CALCULER l'HISTOGRAMME du graphe affich√©
function lancerHistogram(nodes, edges) {

if (!lastGraphOptions.showEdges) {
showNotification(" Le graphe affich√© ne contient pas de liens entre les mots, calcul de l'histogramme annul√©.");
return;
}

  if (nodes.length > 2000) {
    demanderConfirmation(`‚ö†Ô∏è Le graphe contient ${nodes.length} mots. Le calcul va √™tre long. Voulez-vous l'effectuer ?`, function(reponse) {
      if (reponse) {
	   showNotification(" Calcul de l'histogramme en cours, patientez.");
        const histogram = calculateHistogram(nodes, edges);
        const message = formatHistogram(histogram);
        showNotif(message);
      } else {
        showNotification(" Calcul de l'histogramme annul√©.");
      }
    });
  } else {
	 showNotification("Calcul de l'histogramme en cours, patientez.");     
	setTimeout(() => {   // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour
      const histogram = calculateHistogram(nodes, edges);
      const message = formatHistogram(histogram);
      showNotif(message);
    }, 100);
  }
}
function calculateHistogram(nodes, edges) {  
	  nodes = s.graph.nodes().filter(n => !n.hidden);
      edges = s.graph.edges().filter(e => !e.hidden);
   const histogram = {};
    nodes.forEach(node => {
        const degree = edges.filter(edge =>
            edge.source === node.id || edge.target === node.id
        ).length/2;	 
        if (!histogram[degree]) {
            histogram[degree] = { count: 0, ids: [] };
        }
        histogram[degree].count++;
        histogram[degree].ids.push(node.label);
    });
    return histogram;
}
// Fonction pour formater l'HISTOGRAMME en une cha√Æne lisible
function formatHistogram(histogram) {
    let formattedMessage = "Histogramme du graphe affich√© <br> nombre de liens : nombre de mots (mots dans ce cas)<br>";
    for (const degree in histogram) {
        formattedMessage += `${degree}: ${histogram[degree].count} `;
        if (histogram[degree].ids.length > 0) {
            formattedMessage += ` (${histogram[degree].ids.slice(0, 100).join(', ')})`;
        }
        formattedMessage += "<br>";
    }
    return formattedMessage;
}
// GESTIONNAIRE DU BOUTON SHOW-HISTO-BTN
document.getElementById("show-histo-btn").addEventListener("click", function() {
   
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©.");
        return;
    }
	
    // R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();
    // Calculer l'histogramme
    const histogram = lancerHistogram(nodes, edges);
    // Afficher l'histogramme dans la console
	// console.log("‚úÖ Histogramme du graphe affich√© :", histogram);	
	// Formater l'histogramme en message lisible
    const message = formatHistogram(histogram);
	//console.log("‚úÖ Histogramme du graphe affich√© format√©:", message);
    // Afficher l'histogramme dans la zone de notification
	// showNotif(message);
});
// FIN Fonction pour calculer l'HISTOGRAMME du graphe affich√©

//////COMPLETUDE DU GRAPHE AFFICH√â
document.getElementById("completude-btn").addEventListener("click", completeGraphEdgesFromInitial);

function completeGraphEdgesFromInitial() {
   if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, compl√©tude impossible. ");
        return;
    }
	
	if (s.graph.nodes().length < 2000) { 
	calculcompletude ();
	}
	else {
    demanderConfirmation(`‚ö†Ô∏è Le graphe contient ${s.graph.nodes().length } mots. Le calcul va √™tre long. Voulez-vous l'effectuer ?`, function(reponse)
	{
      if (!reponse) { 
        showNotification(" Calcul de la compl√©tude annul√©.");
		return;
      }
   else {
	  calculcompletude ();
}
});
}
}
function calculcompletude ()
{
showNotification("Calcul de la compl√©tude en cours, patientez.");  
    const currentNodes = s.graph.nodes();
    const currentEdges = s.graph.edges();
    const currentNodeIds = new Set(currentNodes.map(n => n.id));

    // üîç Construire un ensemble d'ar√™tes existantes (source+target ou target+source)
    const existingEdgeKeys = new Set(
        currentEdges.map(e => {
            const a = [e.source, e.target].sort().join("‚Üî");
            return a;
        })
    );
    const completedEdges = [];
	let newEdgesCount = 0;	 
    storedGraphEncours.edges.forEach(edge => {
        if (
            currentNodeIds.has(edge.source) &&
            currentNodeIds.has(edge.target)
        ) {
            const edgeKey = [edge.source, edge.target].sort().join("‚Üî");
            // ‚úÖ Si l‚Äôar√™te est d√©j√† pr√©sente, on la garde telle quelle
            if (existingEdgeKeys.has(edgeKey)) {
                completedEdges.push(edge);
            }
            // ‚úÖ Sinon, on ajoute une nouvelle ar√™te en gris
            else {
                completedEdges.push({
                    ...edge,
                    color: "#7f8c8d"  // üé® Gris pour les nouvelles ar√™tes
                });
				newEdgesCount++;
            }
        }
    });
	 //  Construction du graphe avec tous les n≈ìuds visibles
    let completedGraph = {
        nodes: [...currentNodes],
        edges: completedEdges
    }; 
    //console.log("üìå Ar√™tes totales :", completedEdges.length/2);    
	displayGraph(completedGraph, { rescale: 0.6 });
	setTimeout(() => {
			startForceAtlas2(completedGraph ,100);	
			const camera = s.camera;
			const zoomRatio = 0.8; // >1 pour zoomer, <1 pour d√©zoomer
			camera.goTo({
				ratio: camera.ratio / zoomRatio  
				});	
		}, 200); // petit d√©lai pour garantir que s est pr√™t
		
		updateTitreGraph("Graphe Compl√©tude");
}
//////FIN COMPLETUDE du graphe affich√©

	
///////EXTENSION ajout des syno au graphe affich√©	///////////////
// fonction associ√©e au bouton "Extension"
document.getElementById("extension-btn").addEventListener( "click", function () {
   
    // R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();
	lancerExtention(nodes, edges) ;
});

// Fonction pour lancer puis calculer l'EXTENSION du graphe affich√©
function lancerExtention(nodes, edges) { 

 // ‚úÖ V√©rifier si un graphe est affich√©  
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, extension impossible. ");
        return;
    }
  
  if (nodes.length > 100) {
    demanderConfirmation(`‚ö†Ô∏è Le graphe contient ${nodes.length} mots. Le calcul va √™tre long. Voulez-vous l'effectuer ?`, function(reponse)
	{
      if (reponse) {
        const extension = calculateExtension(nodes, edges);
		} else {
        showNotification(" Calcul de l'extension annul√©.");
		}
    });
  } else
	{
	 showNotification("Calcul de l'extension en cours, patientez.");     
		setTimeout(() => {   // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour
		const extension = calculateExtension(nodes, edges);
		}, 100);
	}
  
function calculateExtension(nodes,edges) {   
    // ‚úÖ R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√© A
    let baseNodes = [... nodes ];
    let baseEdges = [... edges ];    
    let baseNodeIds = new Set(baseNodes.map(node => node.id)); // üîπ Ensemble des IDs des n≈ìuds existants (A)
    console.log(`üìå N≈ìuds initiaux du graphe affich√© :`, baseNodeIds.size);
   // console.log(`üìå Ar√™tes initiales du graphe affich√© :`, baseEdges.length/2);
    //console.log(`üìå IDs des n≈ìuds initiaux :`, baseNodeIds);
showNotification("Patientez quelques secondes, le traitement peut √™tre long sur un graphe contenant de nombreux mots !");
    // ‚úÖ Trouver les synonymes (voisins) des n≈ìuds du graphe affich√© dans `storedGraphEncours`
    let newNodes = new Set(); // üîπ Stocke les synonymes √† ajouter (B - A)
    let newEdges = []; // üîπ Stocke les nouvelles ar√™tes
    baseNodes.forEach(node => {
        let nodeId = node.id;      
        // üîç R√©cup√©rer les voisins (= synonymes) via les ar√™tes dans le graphe initial
        let synonyms = storedGraphEncours.edges
            .filter(edge => edge.source === nodeId || edge.target === nodeId) // ‚úÖ Garde les ar√™tes connect√©es √† `nodeId`
            .map(edge => edge.source === nodeId ? edge.target : edge.source); // üîÑ R√©cup√®re l‚Äôautre extr√©mit√©

        synonyms.forEach(synonym => {
            if (!baseNodeIds.has(synonym)) {  // ‚úÖ Ne garder que les synonymes **absents** de A
                newNodes.add(synonym);		
            }
        });
    });
    //console.log(`üìå Synonymes uniques ajout√©s (B - A) :`, newNodes.size);
    // ‚úÖ Ajouter les nouvelles ar√™tes entre les synonymes et les n≈ìuds initiaux
    storedGraphEncours.edges.forEach(edge => {
        if (
            (baseNodeIds.has(edge.source) && newNodes.has(edge.target)) ||
            (baseNodeIds.has(edge.target) && newNodes.has(edge.source))
        ) {
            newEdges.push(edge); // ‚úÖ Ajoute uniquement les ar√™tes valides
        }
    });
    //console.log(`üìå Nouvelles ar√™tes ajout√©es :`, newEdges.length/2);
    // ‚úÖ G√©n√©rer le graphe √©tendu
    let extendedGraph = {
        nodes: [...baseNodes], // üîπ On commence avec A
        edges: [...baseEdges, ...newEdges] // üîπ On ajoute les nouvelles ar√™tes
    };
    // ‚úÖ Ajouter les nouveaux synonymes au graphe avec une couleur diff√©rente
    newNodes.forEach(synonym => {
        let originalNode = storedGraphEncours.nodes.find(n => n.id === synonym);
        if (!originalNode) return;		
        // üîπ Ajouter les coordonn√©es du n≈ìud s'il existe dans `storedGraphEncours`
        extendedGraph.nodes.push({
            id: synonym,
            label: originalNode.label ,
			"nombre de synonymes": originalNode["nombre de synonymes"], 
			synonymes: originalNode["synonymes"],
            color: "#70db92", // üé® Couleur sp√©ciale pour les synonymes (violet)
            size: 1  , // üìå Taille plus petite pas pris en compte
            x: originalNode.x || Math.random() * 100, // üîÑ Position al√©atoire si absente
            y: originalNode.y || Math.random() * 100
        });
    });
    // ‚úÖ Afficher le nouveau graphe √©tendu
		displayGraph (extendedGraph, { rescale: false ,  showEdges: false });  //showEdges: false sans afficher les liens
		 
		setTimeout(() => {
			startForceAtlas2(extendedGraph,100);	
			const camera = s.camera;
			const zoomRatio = 0.8; // >1 pour zoomer, <1 pour d√©zoomer
			camera.goTo({
				ratio: camera.ratio / zoomRatio  
				});	
		}, 200); // petit d√©lai pour garantir que s est pr√™t	
updateTitreGraph("Graphe extension, sans liens");		
}

}		 
///////FIN EXTENSION ajout des syno aux mots du graphe affich√©	///////////////

////   MATRICE BINAIRE
document.getElementById("export-matrix-btn").addEventListener("click", function () {
 
  // R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();
	LancerMatriceBinaire(nodes, edges) ;
});

function LancerMatriceBinaire(nodes, edges) {
//  V√©rifier si un graphe est affich√©  
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, calcul matrice impossible. ");
        return;
    }
// verifier si les liens sont affich√©s
	if (!lastGraphOptions.showEdges) {
showNotification(" Le graphe affich√© ne contient pas de liens entre les mots, calcul de la matrice annul√©.");
return;
}
if (nodes.length > 100) {
    demanderConfirmation(`‚ö†Ô∏è Le graphe contient ${nodes.length} mots. Le calcul va √™tre long. Voulez-vous l'effectuer ?`, function(reponse)
	{
      if (reponse) {
        const matricebinaire = CalculateMatriceBinaire(nodes, edges);
		} else {
        showNotification(" Calcul de la matrice annul√©.");
		}
    });
  } else
	{
	 showNotification("Calcul de la matrice de synonymie en cours, patientez.");     
		setTimeout(() => {   // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour
		const matricebinaire = CalculateMatriceBinaire(nodes, edges);
		}, 100);
	}
	
function CalculateMatriceBinaire(nodes,edges) {  
		 	 
	const synonymEdges = s.graph.edges();

	const synonymMap = new Map();
	synonymEdges.forEach(e => {
    const a = e.source;
    const b = e.target;
    if (!synonymMap.has(a)) synonymMap.set(a, new Set());
    if (!synonymMap.has(b)) synonymMap.set(b, new Set());
    synonymMap.get(a).add(b);
    synonymMap.get(b).add(a);
  });
	//console.log("üìå synonymMap :", synonymMap);
	//console.log("üìå Noeuds avec plus de 0 synonymes :", Array.from(synonymMap.entries()).filter(([_, v]) => v.size > 0));

  // ‚ñ∂Ô∏è Ne garder que les adjectifs avec plus de 0 synonymes
  const adjectifs = Array.from(synonymMap.entries())
    .filter(([_, voisins]) => voisins.size > 0)
    .map(([mot]) => mot)
    .sort();

  // ‚ñ∂Ô∏è Matrice binaire
  const matrice = adjectifs.map(a1 =>
    adjectifs.map(a2 => synonymMap.get(a1)?.has(a2) ? 1 : 0)
  );
  
const idToLabel = new Map();
s.graph.nodes().forEach(n => idToLabel.set(n.id, n.label || n.id));

let csv = 'mot,' + adjectifs.map(id => idToLabel.get(id)).join(',') + '\n';

adjectifs.forEach((mot, i) => {
  csv += [idToLabel.get(mot), ...matrice[i]].join(',') + '\n';
});

  // ‚ñ∂Ô∏è T√©l√©charger le fichier CSV
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'matrice_synonymes_filtr√©e.csv';
  a.click();
  URL.revokeObjectURL(url);

  showNotif("‚úÖ Matrice de synonymie export√©e. Fichier CSV dans votre dossier de T√©l√©chargement.");
};
 }
 ////  FIN MATRICE BINAIRE


////MATRICE DES DISTANCES
document.getElementById("export-path-btn").addEventListener("click",function () {

// R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    const nodes = s.graph.nodes();
    const edges = s.graph.edges();
	LancerMatriceDistances(nodes, edges) ;
});

document.getElementById("stop-matrix-btn").addEventListener("click", () => {
    if (calculInProgress) {
        stopMatriceCalcul = true;
        showNotification("‚ùå Annulation demand√©e, patientez...");
    }
});



function LancerMatriceDistances(nodes, edges) {
	//  V√©rifier si un graphe est affich√©  
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, calcul matrice impossible. ");
        return;
    }
	// verifier si les liens sont affich√©s
	if (!lastGraphOptions.showEdges) {
	showNotification(" Le graphe affich√© ne contient pas de liens entre les mots, calcul de la matrice annul√©.");
	return;
	}
	
if (nodes.length > 2) {
    demanderConfirmation(`‚ö†Ô∏è Le graphe contient ${nodes.length} mots. LE CALCUL EST TR√àS LONG si plus de 10 mots ! Voulez-vous l'effectuer ?`, function(reponse)
	{
      if (reponse) {
	  
		stopMatriceCalcul = false; // ‚úÖ R√©initialisation √† chaque lancement
		 calculInProgress = true;
		document.getElementById("stop-matrix-btn").style.display = "inline"; // ‚úÖ Affiche le bouton annulation
	  
		showNotification("Calcul de la matrice des distances en cours, patientez, ce calcul peut √™tre tr√®s long.");     
		setTimeout(() => {   // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour
		
const start = Date.now();
console.log(new Date().toLocaleTimeString(), "üöÄ D√©but du process");
// ... ton process
		CalculateMatriceDistancesDecoupee(nodes, edges, () => {
            const end = Date.now();
            const durationSec = Math.round((end - start) / 1000);
            console.log(new Date().toLocaleTimeString(), `‚úÖ Calcul termin√© en ${durationSec} secondes`);
            calculInProgress = false;
            document.getElementById("stop-matrix-btn").style.display = "none";
        });
						
						}, 100);
		} else {
        showNotification(" Calcul de la matrice annul√©.");
		}
    });
  } else  // si on a 2 points seulement
	{
	 showNotification("Calcul de la matrice des distances en cours, patientez, ce calcul peut √™tre long.");     
		setTimeout(() => {   // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour
		const matricedistances = CalculateMatriceDistances(nodes, edges);
		}, 100);
	}
	
function CalculateMatriceDistancesDecoupee(nodes, edges, callback) {
    const nodesAffiches = s.graph.nodes();
    const nodeIdsAffiches = nodesAffiches.map(n => n.id);

    const fullGraph = {};
    storedGraphComplet.nodes.forEach(n => {
        fullGraph[n.id] = [];
    });
    storedGraphComplet.edges.forEach(edge => {
        fullGraph[edge.source].push(edge.target);
        fullGraph[edge.target].push(edge.source);
    });

   function calculDistancesDepuis(sourceId, targetIdsSet) {
    const distances = {};
    const visited = new Set();
    const queue = [[sourceId, 0]];

    // Cr√©er un set mutable des cibles restantes
    const remainingTargets = new Set(targetIdsSet);
    remainingTargets.delete(sourceId); // on l'enl√®ve si pr√©sent

    while (queue.length > 0) {
        const [current, dist] = queue.shift();
        if (visited.has(current)) continue;
        visited.add(current);
        distances[current] = dist;

        // Si ce n≈ìud est une cible affich√©e, on le retire des cibles restantes
        if (remainingTargets.has(current)) {
            remainingTargets.delete(current);
            // ‚úÖ Si toutes les cibles ont √©t√© atteintes ‚ûî arr√™t anticip√©
            if (remainingTargets.size === 0) break;
        }

        for (let neighbor of fullGraph[current]) {
            if (!visited.has(neighbor)) {
                queue.push([neighbor, dist + 1]);
            }
        }
    }
    return distances;
}


    const distances = {};
    nodeIdsAffiches.forEach(id => distances[id] = {});
    const idToLabel = {};
    s.graph.nodes().forEach(n => { idToLabel[n.id] = n.label; });

    let i = 0;

    function processNext() {
        if (stopMatriceCalcul) {
            showNotification("‚ùå Calcul annul√© par l'utilisateur.");
            console.warn("‚ùå Calcul interrompu par l'utilisateur.");
            calculInProgress = false;
            document.getElementById("stop-matrix-btn").style.display = "none";
            stopMatriceCalcul = false;
            return;
        }

        if (i >= nodeIdsAffiches.length) {
            console.log("‚úÖ Calcul complet termin√©.");
            exportMatriceCSV(distances, nodeIdsAffiches, idToLabel);
            showNotification("‚úÖ Matrice calcul√©e et export√©e.");
            callback();
            return;
        }

        const id_i = nodeIdsAffiches[i];
        console.log(`üîπ Calcul des distances depuis ${id_i} (${i+1}/${nodeIdsAffiches.length})`);
        const distsFrom_i = calculDistancesDepuis(id_i, new Set(nodeIdsAffiches));


        for (let j = i; j < nodeIdsAffiches.length; j++) {
            const id_j = nodeIdsAffiches[j];
            const dist = distsFrom_i[id_j] !== undefined ? distsFrom_i[id_j] : -1;
            distances[id_i][id_j] = dist;
            distances[id_j][id_i] = dist;
        }

        i++;
        setTimeout(processNext, 0); // Lib√®re l'UI √† chaque √©tape
    }

    processNext();
}

function exportMatriceCSV(distances, nodeIdsAffiches, idToLabel) {
    let csv = "Label," + nodeIdsAffiches.map(id => `"${idToLabel[id]}"`).join(",") + "\n";
    nodeIdsAffiches.forEach(i => {
        csv += `"${idToLabel[i]}",` +
            nodeIdsAffiches.map(j => {
                if (i === j) return 0;
                return distances[i][j] !== undefined ? distances[i][j] : -1;
            }).join(",") + "\n";
    });

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "matrice_distances.csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

}

//// FIN MATRICE DES DISTANCES

<!-- FIN DES BOUTONS COLONNE GAUCHE DE LA PAGE  -->	
	


<!-- BOUTONS COLONNE DROITE DE LA PAGE -->

// STOCK CUMUL IMPORT EXPORT 

// Fonction pour STOCKER ET AFFICHER UN GRAPHE en remplacement de celui stock√© pr√©c√©demment
	//copie du graphe affich√© 
	function storeGraph(graph) 
	{
		let nodes = typeof graph.nodes === "function" ? graph.nodes() : Object.values(graph.nodes);
		let edges = typeof graph.edges === "function" ? graph.edges() : Object.values(graph.edges);
		//console.log("üìå V√©rification des attributs des n≈ìuds AVANT stockage :", nodes);

 // Filtrer pour ne garder que les visibles
    nodes = nodes.filter(node => !node.hidden);
    edges = edges.filter(edge => !edge.hidden);

		return {
        nodes: nodes.map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
			catgram: node.catgram || [], 
            antonymes: node.antonymes || [],   
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            "nombre de synonymes": node["nombre de synonymes"] || 0,   
            "synonymes": node.synonymes || [],  
				//liste10: node.liste10 || []      // NE PAS  Conserver les listes
			})),
        edges: edges.map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
			}))
		};
	}
// gestion du bouton "STOKER le graphe affich√© "
	document.getElementById("store-graph-en-0").addEventListener("click", function() {
	
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©.");
        return;
    }
	
    if (s.graph.nodes().length > 0) {
        storedGraph0 = storeGraph(s.graph);
        //console.log("‚úÖ Graphe affich√© stock√© par l'utilisateur :", storedGraph0);
		showNotification('‚úÖ Graphe stock√©');
    } else {
        console.warn(" ‚ùåImpossible de stocker : aucun n≈ìud dans le graphe.");
    }
});
// gestion du bouton "AFFICHER le graphe STOCK√â "
    document.getElementById('show-stored-graph0').addEventListener('click', function() {
		if (storedGraph0 && storedGraph0.nodes.length > 0 && storedGraph0.edges.length > 0) { 
		displayGraph(storedGraph0);
		isAdjacency = false ;
		updateTitreGraph("Affichage du graphe stock√©");
		} else {
			showNotification('‚ùå Pas de graphe stock√©');
		}
	});	
////////////// Fin de la fonction pour stocker et afficher un graphe

///////////////CUMUL DES GRAPHES//////////////////////////////////
	document.getElementById("store-graph-en-1").addEventListener("click", function() {
    
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©.");
        return;
    }
	
	if (s.graph.nodes().length > 0) {
        let newGraph = storeGraph(s.graph);  // ‚úÖ Graphe actuel

        if (!storedGraph1 || !storedGraph1.nodes) {  
            storedGraph1 = newGraph;  // ‚úÖ Premier graphe stock√© normalement
			showNotification ("‚úÖ Premier graphe ajout√© au CUMUL");
        } else {
            // ‚úÖ V√©rifier si le graphe actuel est r√©ellement diff√©rent avant d'ajouter
            let existingNodes = new Map(storedGraph1.nodes.map(node => [node.id, node])); 
            let existingEdges = new Map(storedGraph1.edges.map(edge => [edge.id, edge])); 
            let isNewGraph = false;

            newGraph.nodes.forEach(node => {
                if (!existingNodes.has(node.id)) {
                    existingNodes.set(node.id, node);
                    isNewGraph = true;
                }
            });
            newGraph.edges.forEach(edge => {
                if (!existingEdges.has(edge.id)) {
                    existingEdges.set(edge.id, edge);
                    isNewGraph = true;
                }
            });
            if (isNewGraph) {
                storedGraph1 = {
                    nodes: Array.from(existingNodes.values()),
                    edges: Array.from(existingEdges.values())
                };
                showNotification("‚úÖ Nouveau graphe ajout√© au CUMUL");
            } else {
                showNotification("‚ö†Ô∏è Aucun changement dans la composition des motss et ar√™tes d√©tect√© dans le graphe, stockage ignor√©.");
            }
        }
    } else {
        console.warn("‚ö†Ô∏è Impossible de stocker : aucun mot dans le graphe.");
    }
});
//  FIN  gestion du bouton "stoker le graphe affich√© en 1" CUMUL DES GRAPHES

// SOUSTRACTION DU GRAPHE AFFICH√â DU CUMUL /////////
document.getElementById("subtract-graph-en-1").addEventListener("click", function () {
    if (!storedGraph1 || !storedGraph1.nodes || storedGraph1.nodes.length === 0) {
        showNotification("‚ùå Aucun graphe CUMUL√â √† modifier !");
        return;
    }
    if (!s || s.graph.nodes().length === 0) {
        showNotification("‚ùå Aucun graphe affich√© √† soustraire !");
        return;
    }
    const displayedNodeIds = new Set(s.graph.nodes().map(node => node.id));
    // Supprimer les n≈ìuds affich√©s du cumul
    const remainingNodes = storedGraph1.nodes.filter(node => !displayedNodeIds.has(node.id));
    // Supprimer les ar√™tes qui touchent un n≈ìud supprim√©
    const remainingNodeIds = new Set(remainingNodes.map(node => node.id));
    const remainingEdges = storedGraph1.edges.filter(edge =>
        remainingNodeIds.has(edge.source) && remainingNodeIds.has(edge.target)
    );
    // Mettre √† jour le CUMUL
    storedGraph1 = {
        nodes: remainingNodes,
        edges: remainingEdges
    };
    //console.log("üìå Graphe affich√© retir√© du CUMUL. N≈ìuds restants :", remainingNodes.length);
    showNotification("‚úÖ Le graphe affich√© a √©t√© retir√© du CUMUL.");
});
// FIN SOUSTRACTION DU GRAPHE AFFICH√â DU CUMUL /////////

// VIDER LE CUMUL DES GRAPHES
	document.getElementById("reset-stored-graph-1").addEventListener("click", function()
	{
			if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) 
			{	
				storedGraph1 = { nodes: [], edges: [] };  // ‚úÖ R√©initialisation compl√®te
				//console.log("‚úÖ Graphe stock√© dans le cuml r√©initialis√© :", storedGraph1);
				if (s) {
				s.graph.clear();  // ‚úÖ Effacer l'affichage du graphe
				s.refresh();  // ‚úÖ Rafra√Æchir Sigma.js
			}
			showNotification("‚úÖ Le cumul des graphes stock√©s a √©t√© √©ffac√© !");			
			}
			else
			{
			showNotification('‚ùå Pas de graphe stock√©');	
			};
	});
// FIN VIDER LE CUMUL DES GRAPHES//////////

// AFFICHER LE CUMUL  "Afficher le(s) Graphe(s) Stock√©(s) en 1" 
    document.getElementById('show-stored-graph1').addEventListener('click', function()
		{
		if (storedGraph1 && storedGraph1.nodes.length > 0 && storedGraph1.edges.length > 0) { 
		displayGraph(storedGraph1);
		isAdjacency = false ;
		updateTitreGraph("Affichage du cumul");
		} else {
			showNotification('‚ùå Pas de graphe stock√©');
		}
	});
/////// FIN AFFICHER LE CUMUL ///	

////////////// fonction pour EXPORTER un graphe   
document.getElementById("export-graph").addEventListener("click", function() {
    if (!s) {
        showNotification("‚ùå Aucun graphe √† exporter !");
        return;
    }	
	// ‚úÖ R√©cup√©rer les n≈ìuds et ar√™tes du graphe affich√©
    let graphData = {
        nodes: s.graph.nodes().map(node => ({
            id: node.id,
            label: node.label,
            x: node.x,
            y: node.y,
            size: node.size,
            color: node.color,
			synonymes: node.synonymes || [],
			["nombre de synonymes"]: node["nombre de synonymes"],
            antonymes: node.antonymes || [],
            variantes: node.variantes || [],
            cliques: node.cliques || [],
            //liste10: node.liste10 || []
        })),
        edges: s.graph.edges().map(edge => ({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            size: edge.size,
            color: edge.color
        }))
    };
    // ‚úÖ Convertir en JSON
    let jsonString = JSON.stringify(graphData, null, 4);

    // ‚úÖ Cr√©er un blob et un lien de t√©l√©chargement
    let blob = new Blob([jsonString], { type: "application/json" });
    let a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    //a.download = "graphe_export.json";  // üìå Nom du fichier export√©
	let fileName = prompt("Nom pour le fichier export√©, au format JSON, dans le dossier : T√©l√©chargement", "graphe_export.json");
	if (!fileName) return;  // utilisateur a annul√©
	a.download = fileName.endsWith(".json") ? fileName : fileName + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    //console.log("‚úÖ Exportation r√©ussie !");
});
////////////// FIN fonction pour EXPORTER un graphe   

////////// fonction pour IMPORTER un graphe
// üìå Quand on clique sur le bouton, d√©clencher l'ouverture du s√©lecteur de fichier
document.getElementById("import-graph").addEventListener("click", () => {
    document.getElementById("import-file").click();
});
// üìå G√©rer la s√©lection d‚Äôun fichier JSON
document.getElementById("import-file").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
        try {
            const importedGraph = JSON.parse(e.target.result);
			
			// ‚úÖ D√©tecter si c‚Äôest un graphe r√©duit
      typeDeGraphe = importedGraph.type === "reduit" ? "reduit"  : "standard";
	  if (typeDeGraphe === "reduit") {
        showNotification("‚úÖ Fichier import√© de type r√©duit (avec clusters).");	
}  
      if (!importedGraph.nodes || !importedGraph.edges) {
        showNotification("Le fichier n‚Äôest pas un graphe JSON valide.");
        return;
      }
           console.log("üì• Graphe import√© :", importedGraph);

            // ‚úÖ Afficher le graphe import√© (fonction existante)
			displayGraph(importedGraph);
			 
				startForceAtlas2(s); 
			//console.log("‚úÖ Import termin√© :", importedGraph.nodes.length, "n≈ìuds,", importedGraph.edges.length, "ar√™tes");
			//s.graph.nodes().forEach(n => console.log(n.id, n.x, n.y, n.size));

			s.refresh(); // ‚úÖ Forcer le rafra√Æchissement
        } catch (err) {
            console.error("‚ùå Erreur lors de la lecture du fichier JSON :", err);
            showNotification("Erreur lors de l‚Äôimport du fichier JSON.");
        }
    };
    reader.readAsText(file);
});
////////// FIN fonction pour IMPORTER un graphe

/////////////fontion pour EXPORTER LA LISTE DES LABELS ///////////////////
document.getElementById("export-label").addEventListener("click", function () {
    if (!s || s.graph.nodes().length === 0) {
        alert("‚ùå Aucun graphe affich√© !");
        return;
    }

    // 1. R√©cup√©rer les labels
    let labels = s.graph.nodes().map(node => node.label);

    // 2. Trier les labels par ordre alphab√©tique
    labels.sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));

    // 3. Construire le contenu CSV (une ligne, s√©par√©e par des virgules)
   //mots s√©par√©s par une ,
   const csvContent = labels.join(","); 
   //labels.join("\n") un mot par ligne

    // 4. Demander le nom du fichier √† l'utilisateur
    const fileName = prompt("Nom du fichier CSV √† enregistrer dans le dossier : t√©l√©chargement  ", "mots_du_graphe.csv");
    if (!fileName) return;

    // 5. Cr√©er et d√©clencher le t√©l√©chargement
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = fileName.endsWith(".csv") ? fileName : fileName + ".csv";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    //console.log("‚úÖ Labels export√©s :", labels.length);
});
/////////////FIN fontion pour EXPORTER LA LISTE DES LABELS ///////////////////


/////EXPORT DU GRAPHE AFFICHE EN PDF
function exportGraphToPDF() {
  const container = document.getElementById('graph-container');

  html2canvas(container).then(canvas => {
    const imgData = canvas.toDataURL('image/png');
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    pdf.save("graphe.pdf");
  });
}
/////FIN EXPORT DU GRAPHE AFFICHE EN PDF
// FIN STOCK CUMUL IMPORT EXPORT ///////////////////////
	
/////// COMPOSANTES CONNEXES //////////////////////////////////////	
// ‚úÖ G√©n√®re une couleur unique pour chaque composante
function getColor(index) {
    const colors = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6", 
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ‚úÖ R√©utilise les m√™mes couleurs pour chaque composante
}
///////////bouton composantes connexes  
document.getElementById("show-connected-components-btn").addEventListener("click", function() {
    detectConnectedComponents();
});
//////////calcul des composantes CONNEXES
function detectConnectedComponents() {
  
  if (isFirstComponentDetection) {  
        baseGraphForComponents = {  // ‚úÖ Stocke le graphe affich√© au premier appel seulement
            nodes: [...s.graph.nodes()],  
            edges: [...s.graph.edges()]
        };
        isFirstComponentDetection = false;  // ‚úÖ D√©sactive le stockage pour les appels suivants
    }
	else 
	{ 						//	displayGraph (coloredGraph );
	}

   // let nodes = baseGraphForComponents.nodes;  // ‚úÖ Toujours utiliser le m√™me graphe de r√©f√©rence
   // let edges = baseGraphForComponents.edges;

  let nodes = s.graph.nodes();  // ‚úÖ Toujours utiliser le graphe AFFICH√â
  let edges = s.graph.edges();
    //console.log("üìå Utilisation du graphe affich√© pour les composantes :", nodes.length, "n≈ìuds,", edges.length/2, "ar√™tes");
 
	//  V√©rifier si un graphe est affich√©  
	if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, calcul des connexes impossible. ");
        return;
    }
	// verifier si les liens sont affich√©s
	if (!lastGraphOptions.showEdges) {
	showNotification(" Le graphe affich√© ne contient pas de liens entre les mots, calcul des connexes annul√©.");
	return;
	}

    // ‚úÖ Construire la liste d'adjacence
    let adjacencyList = {};
    nodes.forEach(node => adjacencyList[node.id] = []);
    
    edges.forEach(edge => {
        adjacencyList[edge.source].push(edge.target);
        adjacencyList[edge.target].push(edge.source);
    });

    // ‚úÖ D√©tection des composantes connexes via DFS
    let visited = new Set();
    connectedComponents = [];  // ‚úÖ R√©initialise la liste des composantes

    function dfsIterative(startNodeId, component) {
    let stack = [startNodeId];
    visited.add(startNodeId);

    while (stack.length > 0) {
        let nodeId = stack.pop();
        component.push(nodeId);

        adjacencyList[nodeId].forEach(neighbor => {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                stack.push(neighbor);
            }
        });
    }
}
    nodes.forEach(node => {
    if (!visited.has(node.id)) {
        let component = [];
        dfsIterative(node.id, component);
        connectedComponents.push(component);
    }
});

// Trier les composantes par taille d√©croissante
connectedComponents.sort((a, b) => b.length - a.length);

// Garder les 20 plus grandes
let topComponents = connectedComponents.slice(0, 20);

let allowedNodeIds = new Set(topComponents.flat());

let filteredNodes = nodes.filter(node => allowedNodeIds.has(node.id));
let filteredEdges = edges.filter(edge => allowedNodeIds.has(edge.source) && allowedNodeIds.has(edge.target));

// Rapport en notification
let message = `Nombre total de composantes : ${connectedComponents.length}<br>`;
connectedComponents.forEach((comp, index) => {
    message += `Composante ${index + 1} : ${comp.length} mots<br>`;
});

// ‚ö†Ô∏è Vider le graphe actuel
s.graph.clear();

// ‚úÖ Ajouter les n≈ìuds filtr√©s
filteredNodes.forEach(node => s.graph.addNode(node));

// ‚úÖ Ajouter les ar√™tes filtr√©es
filteredEdges.forEach(edge => s.graph.addEdge(edge));

    // ‚úÖ Appliquer une couleur diff√©rente √† chaque composante connexe
	topComponents.forEach((component, index) => {
    let color = getColor(index);  // ‚úÖ Utilise la m√™me fonction que la l√©gende
    component.forEach(nodeId => {
        let node = s.graph.nodes(nodeId);
        if (node) node.color = color;
    });
});

    // ‚úÖ Sauvegarde le graphe color√© pour pouvoir le r√©afficher plus tard
    coloredGraph = { nodes: [...s.graph.nodes()], edges: [...s.graph.edges()] };
	//console.log("üìå Composantes connexes d√©tect√©es :", connectedComponents);
    // ‚úÖ Rafra√Æchir l'affichage pour voir toutes les composantes color√©es
    s.refresh();
	updateConnectedComponentsUI(topComponents);
	
//////////APPEL DE LA LEGENDE

// ‚úÖ Mise √† jour compl√®te de la l√©gende avant l'affichage
	updateConnectedComponentsUI(topComponents);
// ‚úÖ Forcer l'affichage de la l√©gende apr√®s le calcul des composantes
	setTimeout(() => {
	let legendContainer = document.getElementById("connected-components-legend");
	if (legendContainer) {
    legendContainer.style.display = "block"; // ‚úÖ Assure que la l√©gende est visible
	}
	}, 100); // ‚úÖ Petit d√©lai pour que le DOM soit bien mis √† jour

}
//////////FIN calcul des composantes CONNEXES

///fonction pour avoir des couleurs
function getColor(index) {
    const colors = [
        "#3498db", "#e74c3c", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#d35400", "#34495e", "#95a5a6"
    ];
    return colors[index % colors.length]; // ‚úÖ Assigne une couleur parmi la liste
}

///////////creation dynamique des boutons de CONNEXES
function updateConnectedComponentsUI(components) {

	let legendContainer = document.getElementById("connected-components-legend");

   // ‚úÖ Afficher la l√©gende
    legendContainer.style.display = "block";

    let legendItemsContainer = document.getElementById("connected-components-legend");
	if (legendContainer) {
    legendContainer.style.display = "block"; // ‚úÖ La l√©gende s'affiche d√®s le premier clic
	 legendContainer.innerHTML = "<h3>Composantes connexes</h3> <div id='legend-items'></div>";
}

    components.forEach((component, index) => {
        let color = getColor(index); // üé® Fonction qui g√©n√®re une couleur pour chaque composante
		let nodeCount = component.length; // ‚úÖ R√©cup√®re le nombre de n≈ìuds dans la composante

        // ‚úÖ Cr√©ation d'une pastille de couleur
        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C ${index + 1} (${nodeCount})</span> <!-- ‚úÖ Ajoute le nombre de n≈ìuds -->
        `;

		// ‚úÖ Ajuste dynamiquement le nombre de colonnes en fonction du nombre de pastilles
		legendItemsContainer.style.columnCount = Math.ceil(components.length / 15); 	//titi

        // ‚úÖ Ajoute un √©v√©nement au clic
        legendItem.addEventListener("click", function () {
           // console.log(`üìå Affichage de la composante ${index + 1} avec ${nodeCount} n≈ìuds`);
            displayComponentGraph(index, components);
        });

        legendItemsContainer.appendChild(legendItem);
    });

    // ‚úÖ Ajouter un bouton pour afficher toutes les composantes
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.style.marginTop = "10px";
    showAllButton.style.backgroundColor = "#3498db";  // Bleu Sigma.js
    showAllButton.style.color = "white";
    showAllButton.style.border = "none";
    showAllButton.style.padding = "8px";
    showAllButton.style.borderRadius = "5px";
    showAllButton.style.cursor = "pointer";
    showAllButton.style.fontSize = "14px";
    showAllButton.style.transition = "background 0.3s ease-in-out";

    // ‚úÖ Changement de couleur au survol
    showAllButton.addEventListener("mouseover", function () {
        showAllButton.style.backgroundColor = "#2980b9"; // Bleu fonc√©
    });
    showAllButton.addEventListener("mouseout", function () {
        showAllButton.style.backgroundColor = "#3498db"; // Bleu d'origine
    });

    // ‚úÖ Ajoute l'√©v√©nement de clic pour afficher toutes les composantes
    showAllButton.addEventListener("click", function () {
       // console.log("üìå Affichage de toutes les composantes");
         
		displayGraph(coloredGraph);
		isAdjacency = false ;
    });

    // ‚úÖ Ajouter le bouton au conteneur avant le bouton "Masquer"
    legendContainer.appendChild(showAllButton);

    // ‚úÖ Ajouter un bouton pour masquer la legende des connexes
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.style.marginTop = "10px";
    hideButton.style.backgroundColor = "#bdc3c7";  
    hideButton.style.cursor = "pointer";
	 
	// Ajouter un gestionnaire d'√©v√©nements pour changer la couleur au survol du bouton masquer
	hideButton.addEventListener("mouseover", function() {
    hideButton.style.backgroundColor = "#FF0000"; // Rouge
	});
	hideButton.addEventListener("mouseout", function() {
    hideButton.style.backgroundColor = "#bdc3c7"; // Couleur d'origine
	});

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none";
    });

    legendContainer.appendChild(hideButton);
}
///////////FIN creation dynamique des boutons CONNEXES

///////////////////affichage des CONNEXES
function displayComponentGraph(index, components) {
 
    let componentNodeIds = new Set(components[index]);

    let subGraphNodes = coloredGraph.nodes.filter(node => componentNodeIds.has(node.id));

	// ‚úÖ Appliquer la couleur correcte √† chaque n≈ìud
    let color = getColor(index);
    subGraphNodes.forEach(node => {
        node.color = color; // üé® Applique la couleur correspondant √† la l√©gende
    });
   
   // ‚úÖ V√©rification des ar√™tes : Garde uniquement celles qui connectent les n≈ìuds de la composante
    let subGraphEdges = storedGraphEncours.edges.filter(edge =>
        componentNodeIds.has(edge.source) && componentNodeIds.has(edge.target)
    );
	
  //  console.log(`üìå Affichage de la composante ${index + 1}:`, subGraphNodes.length, "n≈ìuds et", subGraphEdges.length/2, "ar√™tes");

    let componentGraph = { nodes: subGraphNodes, edges: subGraphEdges };

     //affiche les stats
	   updateGraphStats(componentGraph );
	      
        // ‚úÖ Effacer l'ancien graphe et recharger uniquement la composante s√©lectionn√©e
        s.graph.clear();  // ‚úÖ Efface compl√®tement le graphe actuel
        s.graph.read(componentGraph);  // ‚úÖ Charge les nouveaux n≈ìuds et ar√™tes
        s.refresh();  // ‚úÖ Rafra√Æchir l'affichage pour forcer Sigma.js √† afficher les nouvelles donn√©es
		isAdjacency = false ;
		// ‚úÖ V√©rification des n≈ìuds et ar√™tes apr√®s le chargement
		// console.log("üìå N≈ìuds affich√©s :", s.graph.nodes().length);
		// console.log("üìå Ar√™tes affich√©es :", s.graph.edges().length);
		//console.log("‚úÖ Composante affich√©e :", s.graph.nodes().length, "n≈ìuds et", s.graph.edges().length, "ar√™tes");
}
///////////////////FIN affichage des connexes
/////// FIN COMPOSANTES CONNEXES //////////////////////////////////////		
	

///////// FONCTION  calcul COMMUNAUTES SUR LE GRAPHE AFFICH√â //////////
function detectCommunitiesOnCurrentGraph() {
    
//  V√©rifier si un graphe est affich√©  
  if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, calcul des communaut√©s impossible. ");
        return;
    }
	// verifier si les liens sont affich√©s
	if (!lastGraphOptions.showEdges) {
	showNotification(" ‚ùå Le graphe affich√© ne contient pas de liens entre les mots, calcul des communaut√©s annul√©.");
	return;
	}
	
    //  Cr√©er un graphe graphology √† partir du graphe affich√©
    const graph = new graphology.Graph();
    // Ajouter les n≈ìuds
    s.graph.nodes().forEach(node => {
        graph.addNode(node.id, { label: node.label });
    });
    // Ajouter les ar√™tes
    s.graph.edges().forEach(edge => {
        if (graph.hasNode(edge.source) && graph.hasNode(edge.target)) {
            graph.addEdge(edge.source, edge.target);
        }
    });
	//console.log("üìå V√©rification de graphology :", window.graphology); 
	//console.log("üìå V√©rification de graphology-communities-louvain :", window.graphologyCommunitiesLouvain);
	//console.log("üìå Propri√©t√©s disponibles :", Object.keys(window.graphologyCommunitiesLouvain));
	// Appliquer l'algorithme de Louvain  ///////////////////
		window.graphologyCommunitiesLouvain.assign(graph ,{
			resolution: 1,  // ‚úÖ Augmente la sensibilit√© au regroupement
			rng: Math.random, // ‚úÖ Randomisation pour √©viter les blocages
		});  
	///////////////////////////////////////////////////////////////////////
	//  V√©rifier apr√®s assign() que les communaut√©s sont bien ajout√©es dans graph
	//console.log("üìå Communaut√©s d√©tect√©es A :", Object.fromEntries(s.graph.nodes().map(node => [node.id, node.community])));
		//console.log("üìå Nombre de n≈ìuds dans s.graph avant stockage :", s.graph.nodes().length);
		//console.log("üìå Nombre d‚Äôar√™tes dans s.graph avant stockage :", s.graph.edges().length);
	//  V√©rification d√©taill√©e
	const communityData = window.graphologyCommunitiesLouvain.detailed(graph);
	//console.log("üìå D√©tails des communaut√©s :", communityData);
	//  R√©cup√©rer les communaut√©s depuis le graphe
	const communities = {};
	graph.forEachNode((node, attributes) => {
    communities[node] = attributes.community;
	});
	//console.log("üìå Communaut√©s d√©tect√©es :", communities);
    //  Ajouter la communaut√© comme attribut de chaque n≈ìud pour Sigma.js
    s.graph.nodes().forEach(node => {
        node.community = communities[node.id] || 0;  //0 si non d√©tect√©
    });
    //  Assigner une couleur diff√©rente √† chaque communaut√©
    const colorPalette = [
        "#e74c3c", "#3498db", "#2ecc71", "#f1c40f", "#9b59b6",
        "#1abc9c", "#e67e22", "#95a5a6", "#34495e", "#8e44ad"
    ];
   s.graph.nodes().forEach(node => {
       node.color = colorPalette[node.community % colorPalette.length] || "#bdc3c7";
    });		 
    //  Rafra√Æchir le graphe pour afficher les couleurs des communaut√©s
    s.refresh();
	//  Stocker  le graphe avec les communaut√©s et les couleurs dans  storedGraphLouvain
		storedGraphLouvain = { 
		nodes: [...s.graph.nodes()], 
		edges: [...s.graph.edges()] 
		};
	window.graphologyCommunitiesLouvain.assign(graph );

	updateCommunityLegend();  //  Mettre √† jour la l√©gende apr√®s assignation

	//console.log("üìå Stockage dans storedGraphLouvain (apr√®s affectation des  communaut√©) effectu√© !", storedGraphLouvain);
	//console.log("üìå N≈ìuds dans le graphe affich√© :", s.graph.nodes().length);
	//console.log("üìå N≈ìuds dans storedGraphLouvain :", storedGraphLouvain.nodes.length);
	//console.log("üìå Ar√™tes dans storedGraphLouvain :", storedGraphLouvain.edges.length/2);
	//console.log("üìå V√©rification des attributs des n≈ìuds dans storedGraphLouvain :",
	// storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community }))
	//);
	updateCommunityLegend();  //  Mettre √† jour la l√©gende apr√®s assignation

	//s.graph.nodes().forEach(node => {
	// if (node.community === 0) {
	//     console.warn(`‚ö†Ô∏è N≈ìud class√© 0 : ${node.id} (degr√© : ${s.graph.degree(node.id)})`);
	// }
	//});
}
// üìå Associer la fonction au bouton "Communaut√©s"
document.getElementById("detect-communities").addEventListener("click", function() {
    detectCommunitiesOnCurrentGraph();
});

/////////// g√©rer l‚Äôaffichage du bouton et r√©afficher la l√©gende 
document.getElementById("show-legend-btn").addEventListener("click", function() {
    let legendContainer = document.getElementById("community-legend");
    legendContainer.style.display = "block";
    this.style.display = "none"; //  Cacher le bouton apr√®s affichage
});

///////////////////////////////////////
   function displayCommunity(communityId) {
   // console.log(`üìå Affichage de la communaut√© ${communityId}`);

    //  V√©rifier que le graphe initial est bien stock√©
    if (!storedGraphLouvain) {
        console.error("‚ùå ERREUR : le graphe n'est pas d√©fini !");
        return;
    }
	//console.log("üìå storedGraphLouvain avant filtrage des communaut√©s " ,storedGraphLouvain );
	//console.log("üìå attributs des n≈ìuds dans storedGraphLouvain avant filtrage des communaut√©s",
     storedGraphLouvain.nodes.map(n => ({ id: n.id, community: n.community, color: n.color }));
	//console.log(`üìå Type de communityId :`, typeof communityId, `Valeur :`, communityId);
	//  Afficher un exemple de node pour voir son format exact
	//console.log(`üìå Exemple de n≈ìud dans storedGraphLouvain :`, storedGraphLouvain.nodes[0]);

	communityId = Number(communityId); //  Convertit en nombre 
	//  Utiliser le graphe initial pour FILTRER les communaut√©s
    let subGraphNodes = storedGraphLouvain.nodes.filter(node => node.community === communityId);
    let nodeIds = new Set(subGraphNodes.map(n => n.id));  
    console.log(" N≈ìuds s√©lectionn√©s :", subGraphNodes);
    //  Filtrer les ar√™tes pour ne conserver que celles entre ces n≈ìuds
    let subGraphEdges = storedGraphLouvain.edges.filter(edge => 
        nodeIds.has(edge.source) && nodeIds.has(edge.target)
    );
	console.log(`üìå V√©rification des n≈ìuds trouv√©s pour communaut√© ${communityId} :`,subGraphNodes.map(n => ({ id: n.id, community: n.community })));
    //console.log(" Ar√™tes s√©lectionn√©es :", subGraphEdges);
    //  V√©rifier que des ar√™tes existent
    if (subGraphEdges.length === 0) {
        console.warn(`‚ö†Ô∏è Aucun edge trouv√© pour la communaut√© ${communityId}`);
    }
	//  Trouver la couleur de la pastille associ√©e √† la communaut√© s√©lectionn√©e
	let legendItems = document.querySelectorAll(".legend-item"); 
	let color = communityColors[communityId] || "#3498db";
	legendItems.forEach(item => {
    let label = item.querySelector(".legend-label").textContent;
    if (label.includes(`C${communityId} (`)) {
        color = item.querySelector(".color-dot").style.backgroundColor;
    }
	//console.log(` Couleur d√©tect√©e pour communaut√© ${communityId} :`, color);
	//console.log(" Contenu exact des labels :", Array.from(legendItems).map(item =>
	//item.querySelector(".legend-label").textContent
});
	//  Appliquer la couleur aux n≈ìuds
	subGraphNodes.forEach(node => {
    node.color = color;
	});
		
    let communityGraph = { nodes: subGraphNodes, edges: subGraphEdges };
	// console.log(`üìå Graphe de la communaut√© ${communityId} g√©n√©r√© :`, communityGraph);
	//console.log(`üìå Couleur assign√©e √† la communaut√© ${communityId}:`, color);
	//console.log("üìå N≈ìuds color√©s :", subGraphNodes.map(n => ({ id: n.id, color: n.color })));
    //  Afficher uniquement cette communaut√©
	//console.log(`üìå Affichage de la communaut√© ${communityId} (${subGraphNodes.length} n≈ìuds)`);
	
	
//////////////////////
	if (subGraphNodes.length === 1 && subGraphEdges.length === 0) {
  console.warn(`‚ÑπÔ∏è Communaut√© ${communityId} contient un seul mot sans ar√™tes.`);

  let node = subGraphNodes[0];
  node.x = 0;
  node.y = 0;
  node.size = 6;
  node.color = color;

  let soloGraph = { nodes: [node], edges: [] };

  // ‚úÖ M√©thode directe √† la mani√®re de displayComponentGraph
  s.graph.clear();
  s.graph.read(soloGraph);
  s.refresh();
  isAdjacency = false;
  return;
}
  else {
	displayGraph(communityGraph);
}
	isAdjacency = false ;
}

//////////////////////////////////////// LEGENDE  COMMUNAUT√âS
function updateCommunityLegend() {
    let legendContainer = document.getElementById("community-legend");
	let legendItemsContainer = document.getElementById("legend-items");
	//legendItemsContainer.style.columnCount = Math.ceil(connectedComponents.length / 15); // ‚úÖ Ajuste le nombre de colonnes
	//  Afficher la l√©gende lorsqu'on d√©tecte les communaut√©s
    legendContainer.style.display = "block";
    // Vider l'ancienne l√©gende
    legendContainer.innerHTML = "<h3>Communaut√©s</h3><div id='community-items'></div>";
    legendItemsContainer = document.getElementById("community-items");

    //  Cr√©er les pastilles pour chaque communaut√©
    let communityCounts = {};  // üìå Stocke la population de chaque communaut√©
    storedGraphLouvain.nodes.forEach(node => {
        let communityId = node.community;
        if (!communityCounts[communityId]) communityCounts[communityId] = 0;
        communityCounts[communityId]++;
    });
    Object.entries(communityCounts)
    .sort((a, b) => b[1] - a[1])
    .forEach(([communityId, count], index) => {
         
let color = getColor(index);
communityColors[communityId] = color; // üî• enregistre la couleur
        let legendItem = document.createElement("div");
        legendItem.classList.add("legend-item");
        legendItem.innerHTML = `
            <span class="color-dot" style="background-color: ${color};"></span>
            <span class="legend-label">C${communityId} (${count})</span>
        `;
        legendItem.addEventListener("click", function () {
          //  console.log(`üìå Affichage de la communaut√© ${communityId} avec ${count} n≈ìuds`);
            displayCommunity(communityId);
        });
        legendItemsContainer.appendChild(legendItem);
    });

    //  Ajuste dynamiquement le nombre de colonnes
    legendItemsContainer.style.columnCount = Math.ceil(Object.keys(communityCounts).length / 15);
    //  Ajouter un bouton pour afficher toutes les communaut√©s
    let showAllButton = document.createElement("button");
    showAllButton.textContent = "TOUTES";
    showAllButton.classList.add("show-all-button");
	
	showAllButton.addEventListener("click", function () {
       // console.log("üìå Affichage de toutes les communaut√©s");
        
		 displayGraph(storedGraphLouvain);
		 isAdjacency = false ;
    });
	
	//  Ajouter un bouton pour masquer la l√©gende des communaut√©s
    let hideButton = document.createElement("button");
    hideButton.textContent = "Masquer";
    hideButton.classList.add("hide-legend-button");

    hideButton.addEventListener("click", function () {
        legendContainer.style.display = "none"; //  Cache la l√©gende lorsqu'on clique sur "Masquer"
    });	
    legendContainer.appendChild(showAllButton);
	legendContainer.appendChild(hideButton);
}
///////// FIN FONCTION POUR APPLIQUER L'ALGORITHME DE LOUVAIN COMMUNAUTES SUR LE GRAPHE AFFICH√â //////////
	
//  bouton pour alterner  D√âMARRER/ARR√äTER LA SPATIALISATION
    document.getElementById('toggle-forceatlas2').addEventListener('click', function() {
      if (isForceAtlas2Running) {
        s.stopForceAtlas2();
        this.textContent = 'D√©marrer la spatialisation'; 
		isForceAtlas2Running = false;
	  // ‚úÖ Annule le setTimeout si encore actif
	 if (forceAtlasTimeout) {
		clearTimeout(forceAtlasTimeout); // ‚úÖ Annule le r√©affichage automatique
		forceAtlasTimeout = null;
		}
	} 
	else
	{
    startForceAtlas2(s, 10000); // ou dur√©e que tu souhaites
    this.textContent = 'Arr√™ter la spatialisation';
    isForceAtlas2Running = true;
	}
  });
     
//  FIN bouton pour alterner  D√âMARRER/ARR√äTER LA SPATIALISATION

///////////GRAPHE de spatialisation des noeuds FORCEATLAS2 //////////////////
////// appel par defaut duration = 0.6 seconde dur√©e personnalis√©e  exemple 5 secondes  : startForceAtlas2(grapdata, 5000);
function startForceAtlas2(data, duration = 600) {
    s.graph.nodes().forEach(node => {
        if (node.x === undefined || node.y === undefined) {
            console.error(`‚ö†Ô∏è Probl√®me de coordonn√©es pour le n≈ìud ${node.id} (${node.label})`);
        }
    });
    // repositionnement des n≈ìuds avant calcul
    s.graph.nodes().forEach(node => {
        node.x = Math.random();
        node.y = Math.random();
    });
	//lancement 
    s.startForceAtlas2({
        worker: true,
        barnesHutOptimize: true,
        barnesHutTheta: 0.5,
        scalingRatio: 2,
        gravity: 2
    });
    // Stockage du timeout pour pouvoir l‚Äôannuler plus tard
  forceAtlasTimeout = setTimeout(() => {
    if (s.isForceAtlas2Running()) {
      s.stopForceAtlas2();
      isForceAtlas2Running = false;

      const btn = document.getElementById('toggle-forceatlas2');
      if (btn) btn.textContent = 'D√©marrer la spatialisation';
    }

    // R√©utilisation des coordonn√©es courantes pour un affichage propre
    let currentGraph = {
      nodes: s.graph.nodes().map(n => ({ ...n })),
      edges: s.graph.edges().map(e => ({ ...e }))
    };

    // R√©affichage du graphe avec les options pr√©c√©dentes (sans rescale violent)
    //displayGraph(currentGraph, { ...lastDisplayOptions, rescale: 0.6 });

    forceAtlasTimeout = null; // Lib√®re le timeout
	
    }, duration);
}	
///////////FIN graphe de spatialisation FORCEATLAS2 //////////////////

///// IMPORTER DES MOTS
// ‚ñ∂Ô∏è Quand on clique sur le bouton, on simule le clic du champ fichier
document.getElementById("btn-importer-mots").addEventListener("click", () => {
    document.getElementById("file-mots-import").click();
});

// ‚ñ∂Ô∏è Quand un fichier est s√©lectionn√©
document.getElementById("file-mots-import").addEventListener("change", function (e) {
    const fichier = e.target.files[0];
    if (!fichier) {
        alert("‚ùå Aucun fichier s√©lectionn√©.");
        return;
    }
    importerEtAfficherMotsDepuisCSV(fichier);
    // ‚úÖ Remettre le champ √† vide pour autoriser le m√™me fichier une prochaine fois
    this.value = null;
});

function importerEtAfficherMotsDepuisCSV(fichier) {
    const reader = new FileReader();

    reader.onload = function (e) {
        const contenu = e.target.result.trim();
        // üîç Extraire les mots import√©s
        const motsImport√©s = contenu
            .split(',')
            .map(m => m.trim())
            .filter(m => m.length > 0);
        // ‚úÖ V√©rifications de format via le tableau
        if (motsImport√©s.length === 0) {
            alert("‚ùå Aucun mot valide d√©tect√© dans le fichier. Assurez-vous qu'il contient une seule ligne de mots s√©par√©s par des virgules.");
            return;
        }
        // (optionnel) V√©rifie s'il y a des sauts de ligne suspects
        if (contenu.includes('\n')) {
            alert("‚ùå Le fichier semble contenir plusieurs lignes. Seule une ligne de mots s√©par√©s par des virgules est attendue.");
            return;
        }
        const nodesToShow = [];
        const motsNonTrouv√©s = [];
        const labelToNode = {};
        storedGraphEncours.nodes.forEach(node => {
            labelToNode[node.label] = node;
        });
        motsImport√©s.forEach(mot => {
            const node = labelToNode[mot];
            if (node) {
                nodesToShow.push({ ...node });
            } else {
                motsNonTrouv√©s.push(mot);
            }
        });
        if (nodesToShow.length === 0) {
            alert("‚ùå Aucun mot trouv√© dans le graphe.");
            return;
        }
        const subgraph = {
            nodes: nodesToShow,
            edges: []
        };
        displayGraph(subgraph);
        showNotification(`‚úÖ ${nodesToShow.length} mot(s) affich√©(s).`);
        if (motsNonTrouv√©s.length > 0) {
            alert("‚ö†Ô∏è Mots non trouv√©s dans le graphe :\n" + motsNonTrouv√©s.join(', '));
        }
    };
    reader.readAsText(fichier);
}
///FIN IMPORTER DES MOTS

<!-- FIN DES BOUTONS COLONNE DROITE DE LA PAGE -->

/////////////////////// GESTION DES EVENEMENTS ////////////////////
  
// ‚úÖ Fonction pour trouver le CHEMIN LE PLUS COURT entre deux mots dans le graphe
function trouverChemin(graph, sourceLabel, targetLabel) {
  const idLabelMap = {};
  const labelIdMap = {};

  graph.nodes.forEach(n => {
    idLabelMap[n.id] = n.label;
    labelIdMap[n.label] = n.id;
  });
  const sourceId = labelIdMap[sourceLabel];
  const targetId = labelIdMap[targetLabel];
  if (!sourceId || !targetId) return null;
  const visited = new Set();
  const queue = [[sourceId]];
  while (queue.length > 0) {
    const path = queue.shift();
    const current = path[path.length - 1];
    if (current === targetId) return path;
    if (visited.has(current)) continue;
    visited.add(current);
    graph.edges.forEach(edge => {
      if (edge.source === current && !visited.has(edge.target)) {
        queue.push([...path, edge.target]);
      } else if (edge.target === current && !visited.has(edge.source)) {
        queue.push([...path, edge.source]);
      }
    });
  }
  return null;
}
// fin fonction pour trouver le CHEMIN LE PLUS COURT entre deux mots 
 
let modeCheminActif = false;
let selectedNode1 = null;
let grapheAvantChemin = null;
let surlignageActif = null;
//BOUTON RECHERCHE CHEMIN
document.getElementById("btn-mode-chemin").addEventListener("click", () => {

if (!lastGraphDisplayed || !lastGraphDisplayed.nodes || lastGraphDisplayed.nodes.length === 0) {
		showNotification("‚ùå Aucun graphe affich√©, pas de chemin possible. ");
        return;
    }
	else {	
  modeCheminActif = true;
  selectedNode1 = null;
  document.getElementById("btn-mode-chemin").classList.add("active");
  showNotification("Mode chemin activ√© : cliquez sur deux mots.");
  console.log("modeCheminActif",modeCheminActif);
  }
});  
  
/////// Fonction pour gerer le CLIC GAUCHE sur les n≈ìuds
function ClicNodeEvents(s) {
  s.unbind('clickNode');

  s.bind('clickNode', function (e) {
    const clickedNode = e.data.node;
	//console.log("clickedNode", clickedNode);
    //console.log("selectedNode1", selectedNode1);

/////////////////////////////// ‚úÖ MODE CHEMIN ACTIV√â
    if (modeCheminActif) {
	
      if (selectedNode1 && clickedNode && selectedNode1.id === clickedNode.id) {
        showNotification("‚ö†Ô∏è S√©lection annul√©e.");
        selectedNode1 = null;
        s.refresh();
        return;
      }
      if (selectedNode1 && selectedNode1.originalColor) {
        selectedNode1.color = selectedNode1.originalColor;
      }
      // Premier clic
      if (!selectedNode1) {
        if (!clickedNode.originalColor) clickedNode.originalColor = clickedNode.color;
        clickedNode.color = "#1eff00"; // vert
        selectedNode1 = clickedNode;
        s.refresh();
        showNotification(`1er mot : <strong>${clickedNode.label}</strong>`);
        return;
      }
      // Deuxi√®me clic
      const node1 = selectedNode1;
      const node2 = clickedNode;
      selectedNode1 = null;
      modeCheminActif = false;	
	let delay = 0;	
	delay += 1000;	
		setTimeout(() => {
		showNotification(`2√®me mot : <strong>${clickedNode.label}</strong>`);
		}, delay);
	delay += 2000;  
		setTimeout(() => {
		showNotification("Patientez, le traitement peut √™tre long, plusieurs minutes !");
		}, delay); 
		document.getElementById("btn-mode-chemin").classList.remove("active");
     delay += 2000; 	  
		setTimeout(() => {
		const chemin = trouverChemin(storedGraphComplet, node1.label, node2.label);
		if (!chemin) {
			showNotification(`‚ùå Aucun chemin entre <strong>${node1.label}</strong> et <strong>${node2.label}</strong>.`);
			s.refresh();
			return;
		}
		// Surlignage des n≈ìuds
		chemin.forEach(id => {
        const n = s.graph.nodes(id);
        if (n) {
          if (!n.originalColor) n.originalColor = n.color;
          n.color = "#ba1bcc";
        }
		});
		// Surlignage des ar√™tes
		for (let i = 0; i < chemin.length - 1; i++) {
        const source = chemin[i];
        const target = chemin[i + 1];
        s.graph.edges().forEach(edge => {
          const match = (edge.source === source && edge.target === target)
                     || (edge.source === target && edge.target === source);
          if (match) {
            if (!edge.originalColor) edge.originalColor = edge.color;
            edge.color = "#ba1bcc";
          }
        });
		}
		s.refresh();
		const distance = chemin.length - 1;
		const labels = chemin.map(id => {
        const n = storedGraphComplet.nodes.find(n => n.id === id);
        return n ? n.label : id;
      });

      showNotif(`‚úÖ <strong>Chemin, dans le graphe complet, entre ${node1.label} et ${node2.label}</strong> (${distance} √©tape${distance > 1 ? 's' : ''}) :<br>${labels.join(" ‚Üí ")}`);
      surlignageActif = "chemin";
	  }, delay);
    
	 return; // ‚úÖ ne pas continuer vers affichage classique
    }

//////////////////////////// ‚úÖ MODE NORMAL
    vedette = clickedNode;
    highlightNode(vedette.id);
    document.getElementById("show-neighbors-btn").disabled = false;
    document.getElementById("show-cliques-btn").disabled = false;
    document.getElementById("show-syno2-btn").disabled = false;
    document.getElementById("show-adjacency-btn").disabled = false;

	// ‚úÖ r√©cup√©rer un label m√™me si node.label est vide
	const affichageLabel = clickedNode.originalLabel || clickedNode.label || clickedNode.id;
  
	const infoText = document.getElementById('info-text');
    infoText.innerHTML = `<strong style="font-size: 18px; color: red;">${affichageLabel}</strong>`;

    const infoHTML = `
	<p><strong style="font-size: 12px; " ><strong style="font-size: 22px; font-weight: bold; color:red ">${affichageLabel}</strong></p>
	<p><strong style="font-size: 12px; " >Informations dans le dictionnaire complet :</strong></p>		  
      <p>Variantes: ${clickedNode.variantes?.join(', ') || 'Aucune'}</p>
      <p>Catgram: ${clickedNode.catgram?.join(', ') || 'Aucun'}</p>
      <p>Nombre de synonymes: ${clickedNode["nombre de synonymes"] || '0'}</p>
      <p>Synonymes: ${clickedNode.synonymes?.join(', ') || 'Aucun'}</p>
      <p>Antonymes: ${clickedNode.antonymes?.join(', ') || 'Aucun'}</p>
      <p>Cliques:<br> ${clickedNode.cliques?.map(clique => clique.join(', ')).join('<br>') || 'Aucune'}</p>
    `;
    showNotif(infoHTML);
  });
}
 /////// FIN de la fonction pour gerer les evenements au CLIC GAUCHE des n≈ìuds  
   
  // ‚úÖ CLIC  gauche HORS D‚ÄôUN N≈íUD : RESET
  s.bind('clickStage', function () {
    if (surlignageActif === "chemin" && grapheAvantChemin) {
      displayGraph(grapheAvantChemin);
      grapheAvantChemin = null;
    } else {
      s.graph.nodes().forEach(n => {
        if (n.originalColor) n.color = n.originalColor;
      });
      s.graph.edges().forEach(e => {
        if (e.originalColor) e.color = e.originalColor;
      });
      s.refresh();
    }
    modeCheminActif = false;
    selectedNode1 = null;
    vedette = null;
    surlignageActif = null;
  });
 // FIN CLIC gauche HORS D‚ÄôUN N≈íUD : RESET
 
  
 ///gestion du CLIC DROIT SUR UN NOEUD
 function RightClickNodeEvents(s) {
  s.bind('rightClickNode', function (e) {
    const node = e.data.node;
    const nodeId = node.id;
    // ‚úÖ R√©initialiser toutes les couleurs
    s.graph.nodes().forEach(n => {
      n.color = n.originalColor || '#ccc';
    });
    s.graph.edges().forEach(edge => {
      edge.color = edge.originalColor || '#999';
    });
    // ‚úÖ Mettre le n≈ìud cliqu√© en rouge
    if (!node.originalColor) node.originalColor = node.color;
    node.color = '#FF0000';
    const neighborLabels = new Set(); // üß† pour √©viter les doublons
    // ‚úÖ Colorer les voisins et les ar√™tes
    s.graph.edges().forEach(edge => {
      if (edge.source === nodeId || edge.target === nodeId) {
        if (!edge.originalColor) edge.originalColor = edge.color;
        edge.color = '#FF0000';
        const neighborId = edge.source === nodeId ? edge.target : edge.source;
        const neighbor = s.graph.nodes(neighborId);
        if (neighbor) {
          if (!neighbor.originalColor) neighbor.originalColor = neighbor.color;
          neighbor.color = '#FF0000';
          neighborLabels.add(neighbor.label); // ‚úÖ enregistrer le label du voisin
        }
      }
    });
    s.refresh();
    const degree = neighborLabels.size;
    const neighborList = Array.from(neighborLabels).sort().join(", ");
    // ‚úÖ Message enrichi avec la liste des voisins
    showNotif(`<strong>${node.label}</strong> a ${degree} lien(s) dans le graphe affich√©.<br><br><em>Liens vers : </em> ${neighborList}`);
  });

  // CLIC DROIT HORS D‚ÄôUN N≈íUD ‚Üí r√©initialisation
		s.bind('clickStage', function () {
		s.graph.nodes().forEach(n => {
		if (n.originalColor) n.color = n.originalColor;
		});
		s.graph.edges().forEach(e => {
		if (e.originalColor) e.color = e.originalColor;
		});
		s.refresh();
		});
	// fin CLIC DROIT HORS D‚ÄôUN N≈íUD ‚Üí r√©initialisation
}
///FIN gestion du CLIC DROIT SUR UN NOEUD

  
 /////// Fonction pour gerer les evenements SURVOL DES N≈íUDS
  function SurvolNoeud(s) {
    s.bind('overNode', function(e) {
    var node = e.data.node;
		
    // ‚úÖ Affichage temporaire dans une info-bulle (tooltip)
      var tooltip = document.getElementById('node-tooltip');
	
 const affichageLabel = node.originalLabel || node.label || node.id;
    // ‚úÖ Affichage conditionnel selon le type de graphe
    if (typeDeGraphe === "reduit") {
      tooltip.innerHTML = `<strong>${affichageLabel }</strong><br>
        <p>Contenu du cluster :</p>
        <p>${node.membres?.join(', ') || 'Aucun'}</p>`;
    } else {
      tooltip.innerHTML = `<strong>${affichageLabel}</strong><br>
        <p>Nombre de synonymes: ${node["nombre de synonymes"] || '0'}</p>
        <p>Synonymes: ${node.synonymes?.join(', ') || 'Aucun'}</p>`;
    }
    tooltip.style.display = "block";
    tooltip.style.left = `${e.data.captor.clientX + 10}px`;
    tooltip.style.top = `${e.data.captor.clientY + 10}px`;
  });
  s.bind('outNode', function() {
    const tooltip = document.getElementById('node-tooltip');
    tooltip.style.display = "none";
  });
}
 /////// FIN de la fonction pour gerer les evenements SURVOL DES N≈íUDS
  
// Charger le graphe lorsque la page est pr√™te
 window.onload = loadGraph;

// fonction pour permettre le deplacement du popup avec la souris
function makeDraggable(el) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    el.onmousedown = dragMouseDown;
    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }
    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        el.style.top = (el.offsetTop - pos2) + "px";
        el.style.left = (el.offsetLeft - pos1) + "px";
    }
    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}


function demanderConfirmation(message, callback) {
  const box = document.getElementById("confirmation-box");
  const messageDiv = document.getElementById("confirmation-message");
  const btnYes = document.getElementById("confirm-yes");
  const btnNo = document.getElementById("confirm-no");
  // Injecter le message
  messageDiv.innerHTML = message;
  box.style.display = "block";
  // Nettoyer les anciens √©couteurs si relanc√©
  const cloneYes = btnYes.cloneNode(true);
  const cloneNo = btnNo.cloneNode(true);
  btnYes.parentNode.replaceChild(cloneYes, btnYes);
  btnNo.parentNode.replaceChild(cloneNo, btnNo);
  cloneYes.addEventListener("click", () => {
    box.style.display = "none";
    callback(true);
  });
  cloneNo.addEventListener("click", () => {
    box.style.display = "none";
    callback(false);
  });
}

 
</script>
<!-- fin du script js----------------------------------------------------------------------------------------------------- -->
  
  <div id="graph-message" style="display:none; position:fixed; top:100px; left:260px; background:#b4fc95; padding:10px; border:1px solid #ccc; border-radius:5px; max-width:300px; cursor:move; z-index:1000;"></div>
 
	
		<!-- ‚úÖ Bo√Æte de confirmation personnalis√©e -->
	<div id="confirmation-box" style="display:none; position: fixed; top: 30%; left: 50%; transform: translate(-50%, -50%);
	background-color: #fff; border: 2px solid #444; padding: 20px; z-index: 9999; width: 200px; box-shadow: 0 0 10px rgba(0,0,0,0.4);">
	<div id="confirmation-message" style="margin-bottom: 20px; font-weight: bold;"></div>
	<button id="confirm-yes" style="margin-right: 20px;"> Oui</button>
	<button id="confirm-no"> Non</button>
	</div>

  
</body>
</html>
